// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package s3 provides a client for Amazon Simple Storage Service.
package s3

import (
	"io"
	"sync"
	"time"
	"net/url"
	"github.com/ks3sdklib/aws-sdk-go/aws"
)

var oprw sync.Mutex

// AbortMultipartUploadRequest generates a request for the AbortMultipartUpload operation.
func (c *S3) AbortMultipartUploadRequest(input *AbortMultipartUploadInput) (req *aws.Request, output *AbortMultipartUploadOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opAbortMultipartUpload == nil {
		opAbortMultipartUpload = &aws.Operation{
			Name:       "AbortMultipartUpload",
			HTTPMethod: "DELETE",
			HTTPPath:   "/{Bucket}/{Key+}",
		}
	}

	if input == nil {
		input = &AbortMultipartUploadInput{}
	}

	req = c.newRequest(opAbortMultipartUpload, input, output)
	output = &AbortMultipartUploadOutput{}
	req.Data = output
	return
}

// Aborts a multipart upload.
//
// To verify that all parts have been removed, so you don't get charged for
// the part storage, you should call the List Parts operation and ensure the
// parts list is empty.
func (c *S3) AbortMultipartUpload(input *AbortMultipartUploadInput) (*AbortMultipartUploadOutput, error) {
	req, out := c.AbortMultipartUploadRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) AbortMultipartUploadPresignedUrl(input *AbortMultipartUploadInput,expires time.Duration)(* url.URL,error){
	req,_ := c.AbortMultipartUploadRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}
var opAbortMultipartUpload *aws.Operation

// CompleteMultipartUploadRequest generates a request for the CompleteMultipartUpload operation.
func (c *S3) CompleteMultipartUploadRequest(input *CompleteMultipartUploadInput) (req *aws.Request, output *CompleteMultipartUploadOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opCompleteMultipartUpload == nil {
		opCompleteMultipartUpload = &aws.Operation{
			Name:       "CompleteMultipartUpload",
			HTTPMethod: "POST",
			HTTPPath:   "/{Bucket}/{Key+}",
		}
	}

	if input == nil {
		input = &CompleteMultipartUploadInput{}
	}

	req = c.newRequest(opCompleteMultipartUpload, input, output)
	output = &CompleteMultipartUploadOutput{}
	req.Data = output
	return
}

// Completes a multipart upload by assembling previously uploaded parts.
func (c *S3) CompleteMultipartUpload(input *CompleteMultipartUploadInput) (*CompleteMultipartUploadOutput, error) {
	req, out := c.CompleteMultipartUploadRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) CompleteMultipartUploadPresignedUrl(input *CompleteMultipartUploadInput,expires time.Duration)(* url.URL,error){
	req,_ := c.CompleteMultipartUploadRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opCompleteMultipartUpload *aws.Operation

// CopyObjectRequest generates a request for the CopyObject operation.
func (c *S3) CopyObjectRequest(input *CopyObjectInput) (req *aws.Request, output *CopyObjectOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opCopyObject == nil {
		opCopyObject = &aws.Operation{
			Name:       "CopyObject",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}/{Key+}",
		}
	}

	if input == nil {
		input = &CopyObjectInput{}
	}

	req = c.newRequest(opCopyObject, input, output)
	output = &CopyObjectOutput{}
	req.Data = output
	return
}

// Creates a copy of an object that is already stored in Amazon S3.
func (c *S3) CopyObject(input *CopyObjectInput) (*CopyObjectOutput, error) {
	req, out := c.CopyObjectRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) CopyObjectPresignedUrl(input *CopyObjectInput,expires time.Duration)(* url.URL,error){
	req,_ := c.CopyObjectRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opCopyObject *aws.Operation

// CreateBucketRequest generates a request for the CreateBucket operation.
func (c *S3) CreateBucketRequest(input *CreateBucketInput) (req *aws.Request, output *CreateBucketOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opCreateBucket == nil {
		opCreateBucket = &aws.Operation{
			Name:       "CreateBucket",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}",
		}
	}

	if input == nil {
		input = &CreateBucketInput{}
	}

	req = c.newRequest(opCreateBucket, input, output)
	output = &CreateBucketOutput{}
	req.Data = output
	return
}

// Creates a new bucket.
func (c *S3) CreateBucket(input *CreateBucketInput) (*CreateBucketOutput, error) {
	req, out := c.CreateBucketRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) CreateBucketPresignedUrl(input *CreateBucketInput,expires time.Duration)(* url.URL,error){
	req,_ := c.CreateBucketRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opCreateBucket *aws.Operation

// CreateMultipartUploadRequest generates a request for the CreateMultipartUpload operation.
func (c *S3) CreateMultipartUploadRequest(input *CreateMultipartUploadInput) (req *aws.Request, output *CreateMultipartUploadOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opCreateMultipartUpload == nil {
		opCreateMultipartUpload = &aws.Operation{
			Name:       "CreateMultipartUpload",
			HTTPMethod: "POST",
			HTTPPath:   "/{Bucket}/{Key+}?uploads",
		}
	}

	if input == nil {
		input = &CreateMultipartUploadInput{}
	}

	req = c.newRequest(opCreateMultipartUpload, input, output)
	output = &CreateMultipartUploadOutput{}
	req.Data = output
	return
}

// Initiates a multipart upload and returns an upload ID.
//
// Note: After you initiate multipart upload and upload one or more parts,
// you must either complete or abort multipart upload in order to stop getting
// charged for storage of the uploaded parts. Only after you either complete
// or abort multipart upload, Amazon S3 frees up the parts storage and stops
// charging you for the parts storage.
func (c *S3) CreateMultipartUpload(input *CreateMultipartUploadInput) (*CreateMultipartUploadOutput, error) {
	req, out := c.CreateMultipartUploadRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) CreateMultipartUploadPresignedUrl(input *CreateMultipartUploadInput,expires time.Duration)(* url.URL,error){
	req,_ := c.CreateMultipartUploadRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opCreateMultipartUpload *aws.Operation

// DeleteBucketRequest generates a request for the DeleteBucket operation.
func (c *S3) DeleteBucketRequest(input *DeleteBucketInput) (req *aws.Request, output *DeleteBucketOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteBucket == nil {
		opDeleteBucket = &aws.Operation{
			Name:       "DeleteBucket",
			HTTPMethod: "DELETE",
			HTTPPath:   "/{Bucket}",
		}
	}

	if input == nil {
		input = &DeleteBucketInput{}
	}

	req = c.newRequest(opDeleteBucket, input, output)
	output = &DeleteBucketOutput{}
	req.Data = output
	return
}

// Deletes the bucket. All objects (including all object versions and Delete
// Markers) in the bucket must be deleted before the bucket itself can be deleted.
func (c *S3) DeleteBucket(input *DeleteBucketInput) (*DeleteBucketOutput, error) {
	req, out := c.DeleteBucketRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) DeleteBucketPresignedUrl(input *DeleteBucketInput,expires time.Duration)(* url.URL,error){
	req,_ := c.DeleteBucketRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opDeleteBucket *aws.Operation

// DeleteBucketCORSRequest generates a request for the DeleteBucketCORS operation.
func (c *S3) DeleteBucketCORSRequest(input *DeleteBucketCORSInput) (req *aws.Request, output *DeleteBucketCORSOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteBucketCORS == nil {
		opDeleteBucketCORS = &aws.Operation{
			Name:       "DeleteBucketCors",
			HTTPMethod: "DELETE",
			HTTPPath:   "/{Bucket}?cors",
		}
	}

	if input == nil {
		input = &DeleteBucketCORSInput{}
	}

	req = c.newRequest(opDeleteBucketCORS, input, output)
	output = &DeleteBucketCORSOutput{}
	req.Data = output
	return
}

// Deletes the cors configuration information set for the bucket.
func (c *S3) DeleteBucketCORS(input *DeleteBucketCORSInput) (*DeleteBucketCORSOutput, error) {
	req, out := c.DeleteBucketCORSRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) DeleteBucketCORSPresignedUrl(input *DeleteBucketCORSInput,expires time.Duration)(* url.URL,error){
	req,_ := c.DeleteBucketCORSRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opDeleteBucketCORS *aws.Operation

// DeleteBucketLifecycleRequest generates a request for the DeleteBucketLifecycle operation.
func (c *S3) DeleteBucketLifecycleRequest(input *DeleteBucketLifecycleInput) (req *aws.Request, output *DeleteBucketLifecycleOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteBucketLifecycle == nil {
		opDeleteBucketLifecycle = &aws.Operation{
			Name:       "DeleteBucketLifecycle",
			HTTPMethod: "DELETE",
			HTTPPath:   "/{Bucket}?lifecycle",
		}
	}

	if input == nil {
		input = &DeleteBucketLifecycleInput{}
	}

	req = c.newRequest(opDeleteBucketLifecycle, input, output)
	output = &DeleteBucketLifecycleOutput{}
	req.Data = output
	return
}

// Deletes the lifecycle configuration from the bucket.
func (c *S3) DeleteBucketLifecycle(input *DeleteBucketLifecycleInput) (*DeleteBucketLifecycleOutput, error) {
	req, out := c.DeleteBucketLifecycleRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) DeleteBucketLifecyclePresignedUrl(input *DeleteBucketLifecycleInput,expires time.Duration)(* url.URL,error){
	req,_ := c.DeleteBucketLifecycleRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}


var opDeleteBucketLifecycle *aws.Operation

// DeleteBucketPolicyRequest generates a request for the DeleteBucketPolicy operation.
func (c *S3) DeleteBucketPolicyRequest(input *DeleteBucketPolicyInput) (req *aws.Request, output *DeleteBucketPolicyOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteBucketPolicy == nil {
		opDeleteBucketPolicy = &aws.Operation{
			Name:       "DeleteBucketPolicy",
			HTTPMethod: "DELETE",
			HTTPPath:   "/{Bucket}?policy",
		}
	}

	if input == nil {
		input = &DeleteBucketPolicyInput{}
	}

	req = c.newRequest(opDeleteBucketPolicy, input, output)
	output = &DeleteBucketPolicyOutput{}
	req.Data = output
	return
}

// Deletes the policy from the bucket.
func (c *S3) DeleteBucketPolicy(input *DeleteBucketPolicyInput) (*DeleteBucketPolicyOutput, error) {
	req, out := c.DeleteBucketPolicyRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) DeleteBucketPolicyPresignedUrl(input *DeleteBucketPolicyInput,expires time.Duration)(* url.URL,error){
	req,_ := c.DeleteBucketPolicyRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opDeleteBucketPolicy *aws.Operation

// DeleteBucketReplicationRequest generates a request for the DeleteBucketReplication operation.
func (c *S3) DeleteBucketReplicationRequest(input *DeleteBucketReplicationInput) (req *aws.Request, output *DeleteBucketReplicationOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteBucketReplication == nil {
		opDeleteBucketReplication = &aws.Operation{
			Name:       "DeleteBucketReplication",
			HTTPMethod: "DELETE",
			HTTPPath:   "/{Bucket}?replication",
		}
	}

	if input == nil {
		input = &DeleteBucketReplicationInput{}
	}

	req = c.newRequest(opDeleteBucketReplication, input, output)
	output = &DeleteBucketReplicationOutput{}
	req.Data = output
	return
}

func (c *S3) DeleteBucketReplication(input *DeleteBucketReplicationInput) (*DeleteBucketReplicationOutput, error) {
	req, out := c.DeleteBucketReplicationRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) DeleteBucketReplicationPresignedUrl(input *DeleteBucketReplicationInput,expires time.Duration)(* url.URL,error){
	req,_ := c.DeleteBucketReplicationRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opDeleteBucketReplication *aws.Operation

// DeleteBucketTaggingRequest generates a request for the DeleteBucketTagging operation.
func (c *S3) DeleteBucketTaggingRequest(input *DeleteBucketTaggingInput) (req *aws.Request, output *DeleteBucketTaggingOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteBucketTagging == nil {
		opDeleteBucketTagging = &aws.Operation{
			Name:       "DeleteBucketTagging",
			HTTPMethod: "DELETE",
			HTTPPath:   "/{Bucket}?tagging",
		}
	}

	if input == nil {
		input = &DeleteBucketTaggingInput{}
	}

	req = c.newRequest(opDeleteBucketTagging, input, output)
	output = &DeleteBucketTaggingOutput{}
	req.Data = output
	return
}

// Deletes the tags from the bucket.
func (c *S3) DeleteBucketTagging(input *DeleteBucketTaggingInput) (*DeleteBucketTaggingOutput, error) {
	req, out := c.DeleteBucketTaggingRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) DeleteBucketTaggingPresignedUrl(input *DeleteBucketTaggingInput,expires time.Duration)(* url.URL,error){
	req,_ := c.DeleteBucketTaggingRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opDeleteBucketTagging *aws.Operation

// DeleteBucketWebsiteRequest generates a request for the DeleteBucketWebsite operation.
func (c *S3) DeleteBucketWebsiteRequest(input *DeleteBucketWebsiteInput) (req *aws.Request, output *DeleteBucketWebsiteOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteBucketWebsite == nil {
		opDeleteBucketWebsite = &aws.Operation{
			Name:       "DeleteBucketWebsite",
			HTTPMethod: "DELETE",
			HTTPPath:   "/{Bucket}?website",
		}
	}

	if input == nil {
		input = &DeleteBucketWebsiteInput{}
	}

	req = c.newRequest(opDeleteBucketWebsite, input, output)
	output = &DeleteBucketWebsiteOutput{}
	req.Data = output
	return
}

// This operation removes the website configuration from the bucket.
func (c *S3) DeleteBucketWebsite(input *DeleteBucketWebsiteInput) (*DeleteBucketWebsiteOutput, error) {
	req, out := c.DeleteBucketWebsiteRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) DeleteBucketWebsitePresignedUrl(input *DeleteBucketWebsiteInput,expires time.Duration)(* url.URL,error){
	req,_ := c.DeleteBucketWebsiteRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opDeleteBucketWebsite *aws.Operation

// DeleteObjectRequest generates a request for the DeleteObject operation.
func (c *S3) DeleteObjectRequest(input *DeleteObjectInput) (req *aws.Request, output *DeleteObjectOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteObject == nil {
		opDeleteObject = &aws.Operation{
			Name:       "DeleteObject",
			HTTPMethod: "DELETE",
			HTTPPath:   "/{Bucket}/{Key+}",
		}
	}

	if input == nil {
		input = &DeleteObjectInput{}
	}

	req = c.newRequest(opDeleteObject, input, output)
	output = &DeleteObjectOutput{}
	req.Data = output
	return
}

// Removes the null version (if there is one) of an object and inserts a delete
// marker, which becomes the latest version of the object. If there isn't a
// null version, Amazon S3 does not remove any objects.
func (c *S3) DeleteObject(input *DeleteObjectInput) (*DeleteObjectOutput, error) {
	req, out := c.DeleteObjectRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) DeleteObjectPresignedUrl(input *DeleteObjectInput,expires time.Duration)(* url.URL,error){
	req,_ := c.DeleteObjectRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opDeleteObject *aws.Operation

// DeleteObjectsRequest generates a request for the DeleteObjects operation.
func (c *S3) DeleteObjectsRequest(input *DeleteObjectsInput) (req *aws.Request, output *DeleteObjectsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteObjects == nil {
		opDeleteObjects = &aws.Operation{
			Name:       "DeleteObjects",
			HTTPMethod: "POST",
			HTTPPath:   "/{Bucket}?delete",
		}
	}

	if input == nil {
		input = &DeleteObjectsInput{}
	}

	req = c.newRequest(opDeleteObjects, input, output)
	output = &DeleteObjectsOutput{}
	req.Data = output
	return
}

// This operation enables you to delete multiple objects from a bucket using
// a single HTTP request. You may specify up to 1000 keys.
func (c *S3) DeleteObjects(input *DeleteObjectsInput) (*DeleteObjectsOutput, error) {
	req, out := c.DeleteObjectsRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) DeleteObjectsPresignedUrl(input *DeleteObjectsInput,expires time.Duration)(* url.URL,error){
	req,_ := c.DeleteObjectsRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opDeleteObjects *aws.Operation

// GetBucketACLRequest generates a request for the GetBucketACL operation.
func (c *S3) GetBucketACLRequest(input *GetBucketACLInput) (req *aws.Request, output *GetBucketACLOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetBucketACL == nil {
		opGetBucketACL = &aws.Operation{
			Name:       "GetBucketAcl",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?acl",
		}
	}

	if input == nil {
		input = &GetBucketACLInput{}
	}

	req = c.newRequest(opGetBucketACL, input, output)
	output = &GetBucketACLOutput{}
	req.Data = output
	return
}

// Gets the access control policy for the bucket.
func (c *S3) GetBucketACL(input *GetBucketACLInput) (*GetBucketACLOutput, error) {
	req, out := c.GetBucketACLRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetBucketACLPresignedUrl(input *GetBucketACLInput,expires time.Duration)(* url.URL,error){
	req,_ := c.GetBucketACLRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetBucketACL *aws.Operation

// GetBucketCORSRequest generates a request for the GetBucketCORS operation.
func (c *S3) GetBucketCORSRequest(input *GetBucketCORSInput) (req *aws.Request, output *GetBucketCORSOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetBucketCORS == nil {
		opGetBucketCORS = &aws.Operation{
			Name:       "GetBucketCors",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?cors",
		}
	}

	if input == nil {
		input = &GetBucketCORSInput{}
	}

	req = c.newRequest(opGetBucketCORS, input, output)
	output = &GetBucketCORSOutput{}
	req.Data = output
	return
}

// Returns the cors configuration for the bucket.
func (c *S3) GetBucketCORS(input *GetBucketCORSInput) (*GetBucketCORSOutput, error) {
	req, out := c.GetBucketCORSRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetBucketCORSPresignedUrl(input *GetBucketCORSInput,expires time.Duration)(* url.URL,error){
	req,_ := c.GetBucketCORSRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetBucketCORS *aws.Operation

// GetBucketLifecycleRequest generates a request for the GetBucketLifecycle operation.
func (c *S3) GetBucketLifecycleRequest(input *GetBucketLifecycleInput) (req *aws.Request, output *GetBucketLifecycleOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetBucketLifecycle == nil {
		opGetBucketLifecycle = &aws.Operation{
			Name:       "GetBucketLifecycle",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?lifecycle",
		}
	}

	if input == nil {
		input = &GetBucketLifecycleInput{}
	}

	req = c.newRequest(opGetBucketLifecycle, input, output)
	output = &GetBucketLifecycleOutput{}
	req.Data = output
	return
}

// Returns the lifecycle configuration information set on the bucket.
func (c *S3) GetBucketLifecycle(input *GetBucketLifecycleInput) (*GetBucketLifecycleOutput, error) {
	req, out := c.GetBucketLifecycleRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetBucketLifecyclePresignedUrl(input *GetBucketLifecycleInput,expires time.Duration)(* url.URL,error){
	req,_ := c.GetBucketLifecycleRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetBucketLifecycle *aws.Operation

// GetBucketLocationRequest generates a request for the GetBucketLocation operation.
func (c *S3) GetBucketLocationRequest(input *GetBucketLocationInput) (req *aws.Request, output *GetBucketLocationOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetBucketLocation == nil {
		opGetBucketLocation = &aws.Operation{
			Name:       "GetBucketLocation",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?location",
		}
	}

	if input == nil {
		input = &GetBucketLocationInput{}
	}

	req = c.newRequest(opGetBucketLocation, input, output)
	output = &GetBucketLocationOutput{}
	req.Data = output
	return
}

// Returns the region the bucket resides in.
func (c *S3) GetBucketLocation(input *GetBucketLocationInput) (*GetBucketLocationOutput, error) {
	req, out := c.GetBucketLocationRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetBucketLocationPresignedUrl(input *GetBucketLocationInput,expires time.Duration)(* url.URL,error){
	req,_ := c.GetBucketLocationRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetBucketLocation *aws.Operation

// GetBucketLoggingRequest generates a request for the GetBucketLogging operation.
func (c *S3) GetBucketLoggingRequest(input *GetBucketLoggingInput) (req *aws.Request, output *GetBucketLoggingOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetBucketLogging == nil {
		opGetBucketLogging = &aws.Operation{
			Name:       "GetBucketLogging",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?logging",
		}
	}

	if input == nil {
		input = &GetBucketLoggingInput{}
	}

	req = c.newRequest(opGetBucketLogging, input, output)
	output = &GetBucketLoggingOutput{}
	req.Data = output
	return
}

// Returns the logging status of a bucket and the permissions users have to
// view and modify that status. To use GET, you must be the bucket owner.
func (c *S3) GetBucketLogging(input *GetBucketLoggingInput) (*GetBucketLoggingOutput, error) {
	req, out := c.GetBucketLoggingRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetBucketLoggingPresignedUrl(input *GetBucketLoggingInput,expires time.Duration)(* url.URL,error){
	req,_ := c.GetBucketLoggingRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetBucketLogging *aws.Operation

// GetBucketNotificationRequest generates a request for the GetBucketNotification operation.
func (c *S3) GetBucketNotificationRequest(input *GetBucketNotificationConfigurationRequest) (req *aws.Request, output *NotificationConfigurationDeprecated) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetBucketNotification == nil {
		opGetBucketNotification = &aws.Operation{
			Name:       "GetBucketNotification",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?notification",
		}
	}

	if input == nil {
		input = &GetBucketNotificationConfigurationRequest{}
	}

	req = c.newRequest(opGetBucketNotification, input, output)
	output = &NotificationConfigurationDeprecated{}
	req.Data = output
	return
}

// Deprecated, see the GetBucketNotificationConfiguration operation.
func (c *S3) GetBucketNotification(input *GetBucketNotificationConfigurationRequest) (*NotificationConfigurationDeprecated, error) {
	req, out := c.GetBucketNotificationRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetBucketNotificationPresignedUrl(input *GetBucketNotificationConfigurationRequest,expires time.Duration)(* url.URL,error){
	req,_ := c.GetBucketNotificationRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetBucketNotification *aws.Operation

// GetBucketNotificationConfigurationRequest generates a request for the GetBucketNotificationConfiguration operation.
func (c *S3) GetBucketNotificationConfigurationRequest(input *GetBucketNotificationConfigurationRequest) (req *aws.Request, output *NotificationConfiguration) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetBucketNotificationConfiguration == nil {
		opGetBucketNotificationConfiguration = &aws.Operation{
			Name:       "GetBucketNotificationConfiguration",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?notification",
		}
	}

	if input == nil {
		input = &GetBucketNotificationConfigurationRequest{}
	}

	req = c.newRequest(opGetBucketNotificationConfiguration, input, output)
	output = &NotificationConfiguration{}
	req.Data = output
	return
}

// Returns the notification configuration of a bucket.
func (c *S3) GetBucketNotificationConfiguration(input *GetBucketNotificationConfigurationRequest) (*NotificationConfiguration, error) {
	req, out := c.GetBucketNotificationConfigurationRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetBucketNotificationConfigurationPresignedUrl(input *GetBucketNotificationConfigurationRequest,expires time.Duration)(* url.URL,error){
	req,_ := c.GetBucketNotificationConfigurationRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetBucketNotificationConfiguration *aws.Operation

// GetBucketPolicyRequest generates a request for the GetBucketPolicy operation.
func (c *S3) GetBucketPolicyRequest(input *GetBucketPolicyInput) (req *aws.Request, output *GetBucketPolicyOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetBucketPolicy == nil {
		opGetBucketPolicy = &aws.Operation{
			Name:       "GetBucketPolicy",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?policy",
		}
	}

	if input == nil {
		input = &GetBucketPolicyInput{}
	}

	req = c.newRequest(opGetBucketPolicy, input, output)
	output = &GetBucketPolicyOutput{}
	req.Data = output
	return
}

// Returns the policy of a specified bucket.
func (c *S3) GetBucketPolicy(input *GetBucketPolicyInput) (*GetBucketPolicyOutput, error) {
	req, out := c.GetBucketPolicyRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetBucketPolicyPresignedUrl(input *GetBucketPolicyInput,expires time.Duration)(* url.URL,error){
	req,_ := c.GetBucketPolicyRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetBucketPolicy *aws.Operation

// GetBucketReplicationRequest generates a request for the GetBucketReplication operation.
func (c *S3) GetBucketReplicationRequest(input *GetBucketReplicationInput) (req *aws.Request, output *GetBucketReplicationOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetBucketReplication == nil {
		opGetBucketReplication = &aws.Operation{
			Name:       "GetBucketReplication",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?replication",
		}
	}

	if input == nil {
		input = &GetBucketReplicationInput{}
	}

	req = c.newRequest(opGetBucketReplication, input, output)
	output = &GetBucketReplicationOutput{}
	req.Data = output
	return
}

func (c *S3) GetBucketReplication(input *GetBucketReplicationInput) (*GetBucketReplicationOutput, error) {
	req, out := c.GetBucketReplicationRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetBucketReplicationPresignedUrl(input *GetBucketReplicationInput,expires time.Duration)(* url.URL,error){
	req,_ := c.GetBucketReplicationRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetBucketReplication *aws.Operation

// GetBucketRequestPaymentRequest generates a request for the GetBucketRequestPayment operation.
func (c *S3) GetBucketRequestPaymentRequest(input *GetBucketRequestPaymentInput) (req *aws.Request, output *GetBucketRequestPaymentOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetBucketRequestPayment == nil {
		opGetBucketRequestPayment = &aws.Operation{
			Name:       "GetBucketRequestPayment",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?requestPayment",
		}
	}

	if input == nil {
		input = &GetBucketRequestPaymentInput{}
	}

	req = c.newRequest(opGetBucketRequestPayment, input, output)
	output = &GetBucketRequestPaymentOutput{}
	req.Data = output
	return
}

// Returns the request payment configuration of a bucket.
func (c *S3) GetBucketRequestPayment(input *GetBucketRequestPaymentInput) (*GetBucketRequestPaymentOutput, error) {
	req, out := c.GetBucketRequestPaymentRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetBucketRequestPaymentPresignedUrl(input *GetBucketRequestPaymentInput,expires time.Duration)(* url.URL,error){
	req,_ := c.GetBucketRequestPaymentRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetBucketRequestPayment *aws.Operation

// GetBucketTaggingRequest generates a request for the GetBucketTagging operation.
func (c *S3) GetBucketTaggingRequest(input *GetBucketTaggingInput) (req *aws.Request, output *GetBucketTaggingOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetBucketTagging == nil {
		opGetBucketTagging = &aws.Operation{
			Name:       "GetBucketTagging",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?tagging",
		}
	}

	if input == nil {
		input = &GetBucketTaggingInput{}
	}

	req = c.newRequest(opGetBucketTagging, input, output)
	output = &GetBucketTaggingOutput{}
	req.Data = output
	return
}

// Returns the tag set associated with the bucket.
func (c *S3) GetBucketTagging(input *GetBucketTaggingInput) (*GetBucketTaggingOutput, error) {
	req, out := c.GetBucketTaggingRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetBucketTaggingPresignedUrl(input *GetBucketTaggingInput,expires time.Duration)(* url.URL,error){
	req,_ := c.GetBucketTaggingRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetBucketTagging *aws.Operation

// GetBucketVersioningRequest generates a request for the GetBucketVersioning operation.
func (c *S3) GetBucketVersioningRequest(input *GetBucketVersioningInput) (req *aws.Request, output *GetBucketVersioningOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetBucketVersioning == nil {
		opGetBucketVersioning = &aws.Operation{
			Name:       "GetBucketVersioning",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?versioning",
		}
	}

	if input == nil {
		input = &GetBucketVersioningInput{}
	}

	req = c.newRequest(opGetBucketVersioning, input, output)
	output = &GetBucketVersioningOutput{}
	req.Data = output
	return
}

// Returns the versioning state of a bucket.
func (c *S3) GetBucketVersioning(input *GetBucketVersioningInput) (*GetBucketVersioningOutput, error) {
	req, out := c.GetBucketVersioningRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetBucketVersioningPresignedUrl(input *GetBucketVersioningInput,expires time.Duration)(* url.URL,error){
	req,_ := c.GetBucketVersioningRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetBucketVersioning *aws.Operation

// GetBucketWebsiteRequest generates a request for the GetBucketWebsite operation.
func (c *S3) GetBucketWebsiteRequest(input *GetBucketWebsiteInput) (req *aws.Request, output *GetBucketWebsiteOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetBucketWebsite == nil {
		opGetBucketWebsite = &aws.Operation{
			Name:       "GetBucketWebsite",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?website",
		}
	}

	if input == nil {
		input = &GetBucketWebsiteInput{}
	}

	req = c.newRequest(opGetBucketWebsite, input, output)
	output = &GetBucketWebsiteOutput{}
	req.Data = output
	return
}

// Returns the website configuration for a bucket.
func (c *S3) GetBucketWebsite(input *GetBucketWebsiteInput) (*GetBucketWebsiteOutput, error) {
	req, out := c.GetBucketWebsiteRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetBucketWebsitePresignedUrl(input *GetBucketWebsiteInput,expires time.Duration)(* url.URL,error){
	req,_ := c.GetBucketWebsiteRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetBucketWebsite *aws.Operation

// GetObjectRequest generates a request for the GetObject operation.
func (c *S3) GetObjectRequest(input *GetObjectInput) (req *aws.Request, output *GetObjectOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetObject == nil {
		opGetObject = &aws.Operation{
			Name:       "GetObject",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}/{Key+}",
		}
	}

	if input == nil {
		input = &GetObjectInput{}
	}

	req = c.newRequest(opGetObject, input, output)
	output = &GetObjectOutput{}
	req.Data = output
	return
}

// Retrieves objects from Amazon S3.
func (c *S3) GetObject(input *GetObjectInput) (*GetObjectOutput, error) {
	req, out := c.GetObjectRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetObjectPresignedUrl(input *GetObjectInput,expires time.Duration) (* url.URL,error){
	req,_ := c.GetObjectRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetObject *aws.Operation

// GetObjectACLRequest generates a request for the GetObjectACL operation.
func (c *S3) GetObjectACLRequest(input *GetObjectACLInput) (req *aws.Request, output *GetObjectACLOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetObjectACL == nil {
		opGetObjectACL = &aws.Operation{
			Name:       "GetObjectAcl",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}/{Key+}?acl",
		}
	}

	if input == nil {
		input = &GetObjectACLInput{}
	}

	req = c.newRequest(opGetObjectACL, input, output)
	output = &GetObjectACLOutput{}
	req.Data = output
	return
}

// Returns the access control list (ACL) of an object.
func (c *S3) GetObjectACL(input *GetObjectACLInput) (*GetObjectACLOutput, error) {
	req, out := c.GetObjectACLRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetObjectACLPresignedUrl(input *GetObjectACLInput,expires time.Duration)(* url.URL,error){
	req,_ := c.GetObjectACLRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetObjectACL *aws.Operation

// GetObjectTorrentRequest generates a request for the GetObjectTorrent operation.
func (c *S3) GetObjectTorrentRequest(input *GetObjectTorrentInput) (req *aws.Request, output *GetObjectTorrentOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetObjectTorrent == nil {
		opGetObjectTorrent = &aws.Operation{
			Name:       "GetObjectTorrent",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}/{Key+}?torrent",
		}
	}

	if input == nil {
		input = &GetObjectTorrentInput{}
	}

	req = c.newRequest(opGetObjectTorrent, input, output)
	output = &GetObjectTorrentOutput{}
	req.Data = output
	return
}

// Return torrent files from a bucket.
func (c *S3) GetObjectTorrent(input *GetObjectTorrentInput) (*GetObjectTorrentOutput, error) {
	req, out := c.GetObjectTorrentRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) GetObjectTorrentPresignedUrl(input *GetObjectTorrentInput,expires time.Duration)(* url.URL,error){
	req,_ := c.GetObjectTorrentRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opGetObjectTorrent *aws.Operation

// HeadBucketRequest generates a request for the HeadBucket operation.
func (c *S3) HeadBucketRequest(input *HeadBucketInput) (req *aws.Request, output *HeadBucketOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opHeadBucket == nil {
		opHeadBucket = &aws.Operation{
			Name:       "HeadBucket",
			HTTPMethod: "HEAD",
			HTTPPath:   "/{Bucket}",
		}
	}

	if input == nil {
		input = &HeadBucketInput{}
	}

	req = c.newRequest(opHeadBucket, input, output)
	output = &HeadBucketOutput{}
	req.Data = output
	return
}

// This operation is useful to determine if a bucket exists and you have permission
// to access it.
func (c *S3) HeadBucket(input *HeadBucketInput) (*HeadBucketOutput, error) {
	req, out := c.HeadBucketRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) HeadBucketPresignedUrl(input *HeadBucketInput,expires time.Duration)(* url.URL,error){
	req,_ := c.HeadBucketRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opHeadBucket *aws.Operation

// HeadObjectRequest generates a request for the HeadObject operation.
func (c *S3) HeadObjectRequest(input *HeadObjectInput) (req *aws.Request, output *HeadObjectOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opHeadObject == nil {
		opHeadObject = &aws.Operation{
			Name:       "HeadObject",
			HTTPMethod: "HEAD",
			HTTPPath:   "/{Bucket}/{Key+}",
		}
	}

	if input == nil {
		input = &HeadObjectInput{}
	}

	req = c.newRequest(opHeadObject, input, output)
	output = &HeadObjectOutput{}
	req.Data = output
	return
}

// The HEAD operation retrieves metadata from an object without returning the
// object itself. This operation is useful if you're only interested in an object's
// metadata. To use HEAD, you must have READ access to the object.
func (c *S3) HeadObject(input *HeadObjectInput) (*HeadObjectOutput, error) {
	req, out := c.HeadObjectRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) HeadObjectPresignedUrl(input *HeadObjectInput,expires time.Duration)(* url.URL,error){
	req,_ := c.HeadObjectRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opHeadObject *aws.Operation

// ListBucketsRequest generates a request for the ListBuckets operation.
func (c *S3) ListBucketsRequest(input *ListBucketsInput) (req *aws.Request, output *ListBucketsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opListBuckets == nil {
		opListBuckets = &aws.Operation{
			Name:       "ListBuckets",
			HTTPMethod: "GET",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &ListBucketsInput{}
	}

	req = c.newRequest(opListBuckets, input, output)
	output = &ListBucketsOutput{}
	req.Data = output
	return
}

// Returns a list of all buckets owned by the authenticated sender of the request.
func (c *S3) ListBuckets(input *ListBucketsInput) (*ListBucketsOutput, error) {
	req, out := c.ListBucketsRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) ListBucketsPresignedUrl(input *ListBucketsInput,expires time.Duration)(* url.URL,error){
	req,_ := c.ListBucketsRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opListBuckets *aws.Operation

// ListMultipartUploadsRequest generates a request for the ListMultipartUploads operation.
func (c *S3) ListMultipartUploadsRequest(input *ListMultipartUploadsInput) (req *aws.Request, output *ListMultipartUploadsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opListMultipartUploads == nil {
		opListMultipartUploads = &aws.Operation{
			Name:       "ListMultipartUploads",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?uploads",
			Paginator: &aws.Paginator{
				InputTokens:     []string{"KeyMarker", "UploadIdMarker"},
				OutputTokens:    []string{"NextKeyMarker", "NextUploadIdMarker"},
				LimitToken:      "MaxUploads",
				TruncationToken: "IsTruncated",
			},
		}
	}

	if input == nil {
		input = &ListMultipartUploadsInput{}
	}

	req = c.newRequest(opListMultipartUploads, input, output)
	output = &ListMultipartUploadsOutput{}
	req.Data = output
	return
}

// This operation lists in-progress multipart uploads.
func (c *S3) ListMultipartUploads(input *ListMultipartUploadsInput) (*ListMultipartUploadsOutput, error) {
	req, out := c.ListMultipartUploadsRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) ListMultipartUploadsPresignedUrl(input *ListMultipartUploadsInput,expires time.Duration)(* url.URL,error){
	req,_ := c.ListMultipartUploadsRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

func (c *S3) ListMultipartUploadsPages(input *ListMultipartUploadsInput, fn func(p *ListMultipartUploadsOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.ListMultipartUploadsRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*ListMultipartUploadsOutput), lastPage)
	})
}

var opListMultipartUploads *aws.Operation

// ListObjectVersionsRequest generates a request for the ListObjectVersions operation.
func (c *S3) ListObjectVersionsRequest(input *ListObjectVersionsInput) (req *aws.Request, output *ListObjectVersionsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opListObjectVersions == nil {
		opListObjectVersions = &aws.Operation{
			Name:       "ListObjectVersions",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}?versions",
			Paginator: &aws.Paginator{
				InputTokens:     []string{"KeyMarker", "VersionIdMarker"},
				OutputTokens:    []string{"NextKeyMarker", "NextVersionIdMarker"},
				LimitToken:      "MaxKeys",
				TruncationToken: "IsTruncated",
			},
		}
	}

	if input == nil {
		input = &ListObjectVersionsInput{}
	}

	req = c.newRequest(opListObjectVersions, input, output)
	output = &ListObjectVersionsOutput{}
	req.Data = output
	return
}

// Returns metadata about all of the versions of objects in a bucket.
func (c *S3) ListObjectVersions(input *ListObjectVersionsInput) (*ListObjectVersionsOutput, error) {
	req, out := c.ListObjectVersionsRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) ListObjectVersionsPresignedUrl(input *ListObjectVersionsInput,expires time.Duration)(* url.URL,error){
	req,_ := c.ListObjectVersionsRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

func (c *S3) ListObjectVersionsPages(input *ListObjectVersionsInput, fn func(p *ListObjectVersionsOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.ListObjectVersionsRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*ListObjectVersionsOutput), lastPage)
	})
}

var opListObjectVersions *aws.Operation

// ListObjectsRequest generates a request for the ListObjects operation.
func (c *S3) ListObjectsRequest(input *ListObjectsInput) (req *aws.Request, output *ListObjectsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opListObjects == nil {
		opListObjects = &aws.Operation{
			Name:       "ListObjects",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}",
			Paginator: &aws.Paginator{
				InputTokens:     []string{"Marker"},
				OutputTokens:    []string{"NextMarker || Contents[-1].Key"},
				LimitToken:      "MaxKeys",
				TruncationToken: "IsTruncated",
			},
		}
	}

	if input == nil {
		input = &ListObjectsInput{}
	}

	req = c.newRequest(opListObjects, input, output)
	output = &ListObjectsOutput{}
	req.Data = output
	return
}

// Returns some or all (up to 1000) of the objects in a bucket. You can use
// the request parameters as selection criteria to return a subset of the objects
// in a bucket.
func (c *S3) ListObjects(input *ListObjectsInput) (*ListObjectsOutput, error) {
	req, out := c.ListObjectsRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) ListObjectsPresignedUrl(input *ListObjectsInput,expires time.Duration)(* url.URL,error){
	req,_ := c.ListObjectsRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

func (c *S3) ListObjectsPages(input *ListObjectsInput, fn func(p *ListObjectsOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.ListObjectsRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*ListObjectsOutput), lastPage)
	})
}

var opListObjects *aws.Operation

// ListPartsRequest generates a request for the ListParts operation.
func (c *S3) ListPartsRequest(input *ListPartsInput) (req *aws.Request, output *ListPartsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opListParts == nil {
		opListParts = &aws.Operation{
			Name:       "ListParts",
			HTTPMethod: "GET",
			HTTPPath:   "/{Bucket}/{Key+}",
			Paginator: &aws.Paginator{
				InputTokens:     []string{"PartNumberMarker"},
				OutputTokens:    []string{"NextPartNumberMarker"},
				LimitToken:      "MaxParts",
				TruncationToken: "IsTruncated",
			},
		}
	}

	if input == nil {
		input = &ListPartsInput{}
	}

	req = c.newRequest(opListParts, input, output)
	output = &ListPartsOutput{}
	req.Data = output
	return
}

// Lists the parts that have been uploaded for a specific multipart upload.
func (c *S3) ListParts(input *ListPartsInput) (*ListPartsOutput, error) {
	req, out := c.ListPartsRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) ListPartsPresignedUrl(input *ListPartsInput,expires time.Duration)(* url.URL,error){
	req,_ := c.ListPartsRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

func (c *S3) ListPartsPages(input *ListPartsInput, fn func(p *ListPartsOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.ListPartsRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*ListPartsOutput), lastPage)
	})
}

var opListParts *aws.Operation

// PutBucketACLRequest generates a request for the PutBucketACL operation.
func (c *S3) PutBucketACLRequest(input *PutBucketACLInput) (req *aws.Request, output *PutBucketACLOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutBucketACL == nil {
		opPutBucketACL = &aws.Operation{
			Name:       "PutBucketAcl",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}?acl",
		}
	}

	if input == nil {
		input = &PutBucketACLInput{}
	}

	req = c.newRequest(opPutBucketACL, input, output)
	output = &PutBucketACLOutput{}
	req.Data = output
	return
}

// Sets the permissions on a bucket using access control lists (ACL).
func (c *S3) PutBucketACL(input *PutBucketACLInput) (*PutBucketACLOutput, error) {
	req, out := c.PutBucketACLRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) PutBucketACLPresignedUrl(input *PutBucketACLInput,expires time.Duration)(* url.URL,error){
	req,_ := c.PutBucketACLRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opPutBucketACL *aws.Operation

// PutBucketCORSRequest generates a request for the PutBucketCORS operation.
func (c *S3) PutBucketCORSRequest(input *PutBucketCORSInput) (req *aws.Request, output *PutBucketCORSOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutBucketCORS == nil {
		opPutBucketCORS = &aws.Operation{
			Name:       "PutBucketCors",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}?cors",
		}
	}

	if input == nil {
		input = &PutBucketCORSInput{}
	}

	req = c.newRequest(opPutBucketCORS, input, output)
	output = &PutBucketCORSOutput{}
	req.Data = output
	return
}

// Sets the cors configuration for a bucket.
func (c *S3) PutBucketCORS(input *PutBucketCORSInput) (*PutBucketCORSOutput, error) {
	req, out := c.PutBucketCORSRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) PutBucketCORSPresignedUrl(input *PutBucketCORSInput,expires time.Duration)(* url.URL,error){
	req,_ := c.PutBucketCORSRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opPutBucketCORS *aws.Operation

// PutBucketLifecycleRequest generates a request for the PutBucketLifecycle operation.
func (c *S3) PutBucketLifecycleRequest(input *PutBucketLifecycleInput) (req *aws.Request, output *PutBucketLifecycleOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutBucketLifecycle == nil {
		opPutBucketLifecycle = &aws.Operation{
			Name:       "PutBucketLifecycle",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}?lifecycle",
		}
	}

	if input == nil {
		input = &PutBucketLifecycleInput{}
	}

	req = c.newRequest(opPutBucketLifecycle, input, output)
	output = &PutBucketLifecycleOutput{}
	req.Data = output
	return
}

// Sets lifecycle configuration for your bucket. If a lifecycle configuration
// exists, it replaces it.
func (c *S3) PutBucketLifecycle(input *PutBucketLifecycleInput) (*PutBucketLifecycleOutput, error) {
	req, out := c.PutBucketLifecycleRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) PutBucketLifecyclePresignedUrl(input *PutBucketLifecycleInput,expires time.Duration)(* url.URL,error){
	req,_ := c.PutBucketLifecycleRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opPutBucketLifecycle *aws.Operation

// PutBucketLoggingRequest generates a request for the PutBucketLogging operation.
func (c *S3) PutBucketLoggingRequest(input *PutBucketLoggingInput) (req *aws.Request, output *PutBucketLoggingOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutBucketLogging == nil {
		opPutBucketLogging = &aws.Operation{
			Name:       "PutBucketLogging",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}?logging",
		}
	}

	if input == nil {
		input = &PutBucketLoggingInput{}
	}

	req = c.newRequest(opPutBucketLogging, input, output)
	output = &PutBucketLoggingOutput{}
	req.Data = output
	return
}

// Set the logging parameters for a bucket and to specify permissions for who
// can view and modify the logging parameters. To set the logging status of
// a bucket, you must be the bucket owner.
func (c *S3) PutBucketLogging(input *PutBucketLoggingInput) (*PutBucketLoggingOutput, error) {
	req, out := c.PutBucketLoggingRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) PutBucketLoggingPresignedUrl(input *PutBucketLoggingInput,expires time.Duration)(* url.URL,error){
	req,_ := c.PutBucketLoggingRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opPutBucketLogging *aws.Operation

// PutBucketNotificationRequest generates a request for the PutBucketNotification operation.
func (c *S3) PutBucketNotificationRequest(input *PutBucketNotificationInput) (req *aws.Request, output *PutBucketNotificationOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutBucketNotification == nil {
		opPutBucketNotification = &aws.Operation{
			Name:       "PutBucketNotification",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}?notification",
		}
	}

	if input == nil {
		input = &PutBucketNotificationInput{}
	}

	req = c.newRequest(opPutBucketNotification, input, output)
	output = &PutBucketNotificationOutput{}
	req.Data = output
	return
}

// Deprecated, see the PutBucketNotificationConfiguraiton operation.
func (c *S3) PutBucketNotification(input *PutBucketNotificationInput) (*PutBucketNotificationOutput, error) {
	req, out := c.PutBucketNotificationRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) PutBucketNotificationPresignedUrl(input *PutBucketNotificationInput,expires time.Duration)(* url.URL,error){
	req,_ := c.PutBucketNotificationRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opPutBucketNotification *aws.Operation

// PutBucketNotificationConfigurationRequest generates a request for the PutBucketNotificationConfiguration operation.
func (c *S3) PutBucketNotificationConfigurationRequest(input *PutBucketNotificationConfigurationInput) (req *aws.Request, output *PutBucketNotificationConfigurationOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutBucketNotificationConfiguration == nil {
		opPutBucketNotificationConfiguration = &aws.Operation{
			Name:       "PutBucketNotificationConfiguration",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}?notification",
		}
	}

	if input == nil {
		input = &PutBucketNotificationConfigurationInput{}
	}

	req = c.newRequest(opPutBucketNotificationConfiguration, input, output)
	output = &PutBucketNotificationConfigurationOutput{}
	req.Data = output
	return
}

// Enables notifications of specified events for a bucket.
func (c *S3) PutBucketNotificationConfiguration(input *PutBucketNotificationConfigurationInput) (*PutBucketNotificationConfigurationOutput, error) {
	req, out := c.PutBucketNotificationConfigurationRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) PutBucketNotificationConfigurationPresignedUrl(input *PutBucketNotificationConfigurationInput,expires time.Duration)(* url.URL,error){
	req,_ := c.PutBucketNotificationConfigurationRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opPutBucketNotificationConfiguration *aws.Operation

// PutBucketPolicyRequest generates a request for the PutBucketPolicy operation.
func (c *S3) PutBucketPolicyRequest(input *PutBucketPolicyInput) (req *aws.Request, output *PutBucketPolicyOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutBucketPolicy == nil {
		opPutBucketPolicy = &aws.Operation{
			Name:       "PutBucketPolicy",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}?policy",
		}
	}

	if input == nil {
		input = &PutBucketPolicyInput{}
	}

	req = c.newRequest(opPutBucketPolicy, input, output)
	output = &PutBucketPolicyOutput{}
	req.Data = output
	return
}

// Replaces a policy on a bucket. If the bucket already has a policy, the one
// in this request completely replaces it.
func (c *S3) PutBucketPolicy(input *PutBucketPolicyInput) (*PutBucketPolicyOutput, error) {
	req, out := c.PutBucketPolicyRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) PutBucketPolicyPresignedUrl(input *PutBucketPolicyInput,expires time.Duration)(* url.URL,error){
	req,_ := c.PutBucketPolicyRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opPutBucketPolicy *aws.Operation

// PutBucketReplicationRequest generates a request for the PutBucketReplication operation.
func (c *S3) PutBucketReplicationRequest(input *PutBucketReplicationInput) (req *aws.Request, output *PutBucketReplicationOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutBucketReplication == nil {
		opPutBucketReplication = &aws.Operation{
			Name:       "PutBucketReplication",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}?replication",
		}
	}

	if input == nil {
		input = &PutBucketReplicationInput{}
	}

	req = c.newRequest(opPutBucketReplication, input, output)
	output = &PutBucketReplicationOutput{}
	req.Data = output
	return
}

// Creates a new replication configuration (or replaces an existing one, if
// present).
func (c *S3) PutBucketReplication(input *PutBucketReplicationInput) (*PutBucketReplicationOutput, error) {
	req, out := c.PutBucketReplicationRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) PutBucketReplicationPresignedUrl(input *PutBucketReplicationInput,expires time.Duration)(* url.URL,error){
	req,_ := c.PutBucketReplicationRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opPutBucketReplication *aws.Operation

// PutBucketRequestPaymentRequest generates a request for the PutBucketRequestPayment operation.
func (c *S3) PutBucketRequestPaymentRequest(input *PutBucketRequestPaymentInput) (req *aws.Request, output *PutBucketRequestPaymentOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutBucketRequestPayment == nil {
		opPutBucketRequestPayment = &aws.Operation{
			Name:       "PutBucketRequestPayment",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}?requestPayment",
		}
	}

	if input == nil {
		input = &PutBucketRequestPaymentInput{}
	}

	req = c.newRequest(opPutBucketRequestPayment, input, output)
	output = &PutBucketRequestPaymentOutput{}
	req.Data = output
	return
}

// Sets the request payment configuration for a bucket. By default, the bucket
// owner pays for downloads from the bucket. This configuration parameter enables
// the bucket owner (only) to specify that the person requesting the download
// will be charged for the download. Documentation on requester pays buckets
// can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html
func (c *S3) PutBucketRequestPayment(input *PutBucketRequestPaymentInput) (*PutBucketRequestPaymentOutput, error) {
	req, out := c.PutBucketRequestPaymentRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) PutBucketRequestPaymentPresignedUrl(input *PutBucketRequestPaymentInput,expires time.Duration)(* url.URL,error){
	req,_ := c.PutBucketRequestPaymentRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opPutBucketRequestPayment *aws.Operation

// PutBucketTaggingRequest generates a request for the PutBucketTagging operation.
func (c *S3) PutBucketTaggingRequest(input *PutBucketTaggingInput) (req *aws.Request, output *PutBucketTaggingOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutBucketTagging == nil {
		opPutBucketTagging = &aws.Operation{
			Name:       "PutBucketTagging",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}?tagging",
		}
	}

	if input == nil {
		input = &PutBucketTaggingInput{}
	}

	req = c.newRequest(opPutBucketTagging, input, output)
	output = &PutBucketTaggingOutput{}
	req.Data = output
	return
}

// Sets the tags for a bucket.
func (c *S3) PutBucketTagging(input *PutBucketTaggingInput) (*PutBucketTaggingOutput, error) {
	req, out := c.PutBucketTaggingRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) PutBucketTaggingPresignedUrl(input *PutBucketTaggingInput,expires time.Duration)(* url.URL,error){
	req,_ := c.PutBucketTaggingRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opPutBucketTagging *aws.Operation

// PutBucketVersioningRequest generates a request for the PutBucketVersioning operation.
func (c *S3) PutBucketVersioningRequest(input *PutBucketVersioningInput) (req *aws.Request, output *PutBucketVersioningOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutBucketVersioning == nil {
		opPutBucketVersioning = &aws.Operation{
			Name:       "PutBucketVersioning",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}?versioning",
		}
	}

	if input == nil {
		input = &PutBucketVersioningInput{}
	}

	req = c.newRequest(opPutBucketVersioning, input, output)
	output = &PutBucketVersioningOutput{}
	req.Data = output
	return
}

// Sets the versioning state of an existing bucket. To set the versioning state,
// you must be the bucket owner.
func (c *S3) PutBucketVersioning(input *PutBucketVersioningInput) (*PutBucketVersioningOutput, error) {
	req, out := c.PutBucketVersioningRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) PutBucketVersioningPresignedUrl(input *PutBucketVersioningInput,expires time.Duration)(* url.URL,error){
	req,_ := c.PutBucketVersioningRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opPutBucketVersioning *aws.Operation

// PutBucketWebsiteRequest generates a request for the PutBucketWebsite operation.
func (c *S3) PutBucketWebsiteRequest(input *PutBucketWebsiteInput) (req *aws.Request, output *PutBucketWebsiteOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutBucketWebsite == nil {
		opPutBucketWebsite = &aws.Operation{
			Name:       "PutBucketWebsite",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}?website",
		}
	}

	if input == nil {
		input = &PutBucketWebsiteInput{}
	}

	req = c.newRequest(opPutBucketWebsite, input, output)
	output = &PutBucketWebsiteOutput{}
	req.Data = output
	return
}

// Set the website configuration for a bucket.
func (c *S3) PutBucketWebsite(input *PutBucketWebsiteInput) (*PutBucketWebsiteOutput, error) {
	req, out := c.PutBucketWebsiteRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) PutBucketWebsitePresignedUrl(input *PutBucketWebsiteInput,expires time.Duration)(* url.URL,error){
	req,_ := c.PutBucketWebsiteRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opPutBucketWebsite *aws.Operation

// PutObjectRequest generates a request for the PutObject operation.
func (c *S3) PutObjectRequest(input *PutObjectInput) (req *aws.Request, output *PutObjectOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutObject == nil {
		opPutObject = &aws.Operation{
			Name:       "PutObject",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}/{Key+}",
		}
	}

	if input == nil {
		input = &PutObjectInput{}
	}

	req = c.newRequest(opPutObject, input, output)
	output = &PutObjectOutput{}
	req.Data = output
	return
}

// Adds an object to a bucket.
func (c *S3) PutObject(input *PutObjectInput) (*PutObjectOutput, error) {
	req, out := c.PutObjectRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) PutObjectPresignedUrl(input *PutObjectInput,expires time.Duration)(* url.URL,error){
	req,_ := c.PutObjectRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opPutObject *aws.Operation

// PutObjectACLRequest generates a request for the PutObjectACL operation.
func (c *S3) PutObjectACLRequest(input *PutObjectACLInput) (req *aws.Request, output *PutObjectACLOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutObjectACL == nil {
		opPutObjectACL = &aws.Operation{
			Name:       "PutObjectAcl",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}/{Key+}?acl",
		}
	}

	if input == nil {
		input = &PutObjectACLInput{}
	}

	req = c.newRequest(opPutObjectACL, input, output)
	output = &PutObjectACLOutput{}
	req.Data = output
	return
}

// uses the acl subresource to set the access control list (ACL) permissions
// for an object that already exists in a bucket
func (c *S3) PutObjectACL(input *PutObjectACLInput) (*PutObjectACLOutput, error) {
	req, out := c.PutObjectACLRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) PutObjectACLPresignedUrl(input *PutObjectACLInput,expires time.Duration)(* url.URL,error){
	req,_ := c.PutObjectACLRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opPutObjectACL *aws.Operation

// RestoreObjectRequest generates a request for the RestoreObject operation.
func (c *S3) RestoreObjectRequest(input *RestoreObjectInput) (req *aws.Request, output *RestoreObjectOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opRestoreObject == nil {
		opRestoreObject = &aws.Operation{
			Name:       "RestoreObject",
			HTTPMethod: "POST",
			HTTPPath:   "/{Bucket}/{Key+}?restore",
		}
	}

	if input == nil {
		input = &RestoreObjectInput{}
	}

	req = c.newRequest(opRestoreObject, input, output)
	output = &RestoreObjectOutput{}
	req.Data = output
	return
}

// Restores an archived copy of an object back into Amazon S3
func (c *S3) RestoreObject(input *RestoreObjectInput) (*RestoreObjectOutput, error) {
	req, out := c.RestoreObjectRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) RestoreObjectPresignedUrl(input *RestoreObjectInput,expires time.Duration)(* url.URL,error){
	req,_ := c.RestoreObjectRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opRestoreObject *aws.Operation

// UploadPartRequest generates a request for the UploadPart operation.
func (c *S3) UploadPartRequest(input *UploadPartInput) (req *aws.Request, output *UploadPartOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opUploadPart == nil {
		opUploadPart = &aws.Operation{
			Name:       "UploadPart",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}/{Key+}",
		}
	}

	if input == nil {
		input = &UploadPartInput{}
	}

	req = c.newRequest(opUploadPart, input, output)
	output = &UploadPartOutput{}
	req.Data = output
	return
}

// Uploads a part in a multipart upload.
//
// Note: After you initiate multipart upload and upload one or more parts,
// you must either complete or abort multipart upload in order to stop getting
// charged for storage of the uploaded parts. Only after you either complete
// or abort multipart upload, Amazon S3 frees up the parts storage and stops
// charging you for the parts storage.
func (c *S3) UploadPart(input *UploadPartInput) (*UploadPartOutput, error) {
	req, out := c.UploadPartRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) UploadPartPresignedUrl(input *UploadPartInput,expires time.Duration)(* url.URL,error){
	req,_ := c.UploadPartRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opUploadPart *aws.Operation

// UploadPartCopyRequest generates a request for the UploadPartCopy operation.
func (c *S3) UploadPartCopyRequest(input *UploadPartCopyInput) (req *aws.Request, output *UploadPartCopyOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opUploadPartCopy == nil {
		opUploadPartCopy = &aws.Operation{
			Name:       "UploadPartCopy",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}/{Key+}",
		}
	}

	if input == nil {
		input = &UploadPartCopyInput{}
	}

	req = c.newRequest(opUploadPartCopy, input, output)
	output = &UploadPartCopyOutput{}
	req.Data = output
	return
}

// Uploads a part by copying data from an existing object as data source.
func (c *S3) UploadPartCopy(input *UploadPartCopyInput) (*UploadPartCopyOutput, error) {
	req, out := c.UploadPartCopyRequest(input)
	err := req.Send()
	return out, err
}
func (c *S3) UploadPartCopyPresignedUrl(input *UploadPartCopyInput,expires time.Duration)(* url.URL,error){
	req,_ := c.UploadPartCopyRequest(input)
	req.ExpireTime = expires
	err := req.Sign()
	return req.HTTPRequest.URL,err
}

var opUploadPartCopy *aws.Operation

type AbortMultipartUploadInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	UploadID *string `location:"querystring" locationName:"uploadId" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataAbortMultipartUploadInput `json:"-" xml:"-"`
}

type metadataAbortMultipartUploadInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type AbortMultipartUploadOutput struct {
	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	metadataAbortMultipartUploadOutput `json:"-" xml:"-"`
}

type metadataAbortMultipartUploadOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type AccessControlPolicy struct {
	// A list of grants.
	Grants []*Grant `locationName:"AccessControlList" locationNameList:"Grant" type:"list"`

	Owner *Owner `type:"structure"`

	metadataAccessControlPolicy `json:"-" xml:"-"`
}

type metadataAccessControlPolicy struct {
	SDKShapeTraits bool `type:"structure"`
}

type Bucket struct {
	// Date the bucket was created.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// The name of the bucket.
	Name *string `type:"string"`

	metadataBucket `json:"-" xml:"-"`
}

type metadataBucket struct {
	SDKShapeTraits bool `type:"structure"`
}

type BucketLoggingStatus struct {
	LoggingEnabled *LoggingEnabled `type:"structure"`

	metadataBucketLoggingStatus `json:"-" xml:"-"`
}

type metadataBucketLoggingStatus struct {
	SDKShapeTraits bool `type:"structure"`
}

type CORSConfiguration struct {
	CORSRules []*CORSRule `locationName:"CORSRule" type:"list" flattened:"true"`

	metadataCORSConfiguration `json:"-" xml:"-"`
}

type metadataCORSConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type CORSRule struct {
	// Specifies which headers are allowed in a pre-flight OPTIONS request.
	AllowedHeaders []*string `locationName:"AllowedHeader" type:"list" flattened:"true"`

	// Identifies HTTP methods that the domain/origin specified in the rule is allowed
	// to execute.
	AllowedMethods []*string `locationName:"AllowedMethod" type:"list" flattened:"true"`

	// One or more origins you want customers to be able to access the bucket from.
	AllowedOrigins []*string `locationName:"AllowedOrigin" type:"list" flattened:"true"`

	// One or more headers in the response that you want customers to be able to
	// access from their applications (for example, from a JavaScript XMLHttpRequest
	// object).
	ExposeHeaders []*string `locationName:"ExposeHeader" type:"list" flattened:"true"`

	// The time in seconds that your browser is to cache the preflight response
	// for the specified resource.
	MaxAgeSeconds *int64 `type:"integer"`

	metadataCORSRule `json:"-" xml:"-"`
}

type metadataCORSRule struct {
	SDKShapeTraits bool `type:"structure"`
}

type CloudFunctionConfiguration struct {
	CloudFunction *string `type:"string"`

	// Bucket event for which to send notifications.
	Event *string `type:"string"`

	Events []*string `locationName:"Event" type:"list" flattened:"true"`

	// Optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	ID *string `locationName:"Id" type:"string"`

	InvocationRole *string `type:"string"`

	metadataCloudFunctionConfiguration `json:"-" xml:"-"`
}

type metadataCloudFunctionConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type CommonPrefix struct {
	Prefix *string `type:"string"`

	metadataCommonPrefix `json:"-" xml:"-"`
}

type metadataCommonPrefix struct {
	SDKShapeTraits bool `type:"structure"`
}

type CompleteMultipartUploadInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	MultipartUpload *CompletedMultipartUpload `locationName:"CompleteMultipartUpload" type:"structure"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	UploadID *string `location:"querystring" locationName:"uploadId" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataCompleteMultipartUploadInput `json:"-" xml:"-"`
}

type metadataCompleteMultipartUploadInput struct {
	SDKShapeTraits bool `type:"structure" payload:"MultipartUpload"`
}

type CompleteMultipartUploadOutput struct {
	Bucket *string `type:"string"`

	// Entity tag of the object.
	ETag *string `type:"string"`

	// If the object expiration is configured, this will contain the expiration
	// date (expiry-date) and rule ID (rule-id). The value of rule-id is URL encoded.
	Expiration *string `location:"header" locationName:"x-amz-expiration" type:"string"`

	Key *string `type:"string"`

	Location *string `type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// Version of the object.
	VersionID *string `location:"header" locationName:"x-amz-version-id" type:"string"`

	metadataCompleteMultipartUploadOutput `json:"-" xml:"-"`
}

type metadataCompleteMultipartUploadOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CompletedMultipartUpload struct {
	Parts []*CompletedPart `locationName:"Part" type:"list" flattened:"true"`

	metadataCompletedMultipartUpload `json:"-" xml:"-"`
}

type metadataCompletedMultipartUpload struct {
	SDKShapeTraits bool `type:"structure"`
}

type CompletedPart struct {
	// Entity tag returned when the part was uploaded.
	ETag *string `type:"string"`

	// Part number that identifies the part.
	PartNumber *int64 `type:"integer"`

	metadataCompletedPart `json:"-" xml:"-"`
}

type metadataCompletedPart struct {
	SDKShapeTraits bool `type:"structure"`
}

type Condition struct {
	// The HTTP error code when the redirect is applied. In the event of an error,
	// if the error code equals this value, then the specified redirect is applied.
	// Required when parent element Condition is specified and sibling KeyPrefixEquals
	// is not specified. If both are specified, then both must be true for the redirect
	// to be applied.
	HTTPErrorCodeReturnedEquals *string `locationName:"HttpErrorCodeReturnedEquals" type:"string"`

	// The object key name prefix when the redirect is applied. For example, to
	// redirect requests for ExamplePage.html, the key prefix will be ExamplePage.html.
	// To redirect request for all pages with the prefix docs/, the key prefix will
	// be /docs, which identifies all objects in the docs/ folder. Required when
	// the parent element Condition is specified and sibling HttpErrorCodeReturnedEquals
	// is not specified. If both conditions are specified, both must be true for
	// the redirect to be applied.
	KeyPrefixEquals *string `type:"string"`

	metadataCondition `json:"-" xml:"-"`
}

type metadataCondition struct {
	SDKShapeTraits bool `type:"structure"`
}

type CopyObjectInput struct {
	// The canned ACL to apply to the object.
	ACL *string `location:"header" locationName:"x-amz-acl" type:"string"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Specifies caching behavior along the request/reply chain.
	CacheControl *string `location:"header" locationName:"Cache-Control" type:"string"`

	// Specifies presentational information for the object.
	ContentDisposition *string `location:"header" locationName:"Content-Disposition" type:"string"`

	// Specifies what content encodings have been applied to the object and thus
	// what decoding mechanisms must be applied to obtain the media-type referenced
	// by the Content-Type header field.
	ContentEncoding *string `location:"header" locationName:"Content-Encoding" type:"string"`

	// The language the content is in.
	ContentLanguage *string `location:"header" locationName:"Content-Language" type:"string"`

	// A standard MIME type describing the format of the object data.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// The name of the source bucket and key name of the source object, separated
	// by a slash (/). Must be URL-encoded.
	CopySource *string `location:"header" locationName:"x-amz-copy-source" type:"string" required:"true"`

	// Copies the object if its entity tag (ETag) matches the specified tag.
	CopySourceIfMatch *string `location:"header" locationName:"x-amz-copy-source-if-match" type:"string"`

	// Copies the object if it has been modified since the specified time.
	CopySourceIfModifiedSince *time.Time `location:"header" locationName:"x-amz-copy-source-if-modified-since" type:"timestamp" timestampFormat:"rfc822"`

	// Copies the object if its entity tag (ETag) is different than the specified
	// ETag.
	CopySourceIfNoneMatch *string `location:"header" locationName:"x-amz-copy-source-if-none-match" type:"string"`

	// Copies the object if it hasn't been modified since the specified time.
	CopySourceIfUnmodifiedSince *time.Time `location:"header" locationName:"x-amz-copy-source-if-unmodified-since" type:"timestamp" timestampFormat:"rfc822"`

	// Specifies the algorithm to use when decrypting the source object (e.g., AES256).
	CopySourceSSECustomerAlgorithm *string `location:"header" locationName:"x-amz-copy-source-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use to decrypt
	// the source object. The encryption key provided in this header must be one
	// that was used when the source object was created.
	CopySourceSSECustomerKey *string `location:"header" locationName:"x-amz-copy-source-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	CopySourceSSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-copy-source-server-side-encryption-customer-key-MD5" type:"string"`

	// The date and time at which the object is no longer cacheable.
	Expires *time.Time `location:"header" locationName:"Expires" type:"timestamp" timestampFormat:"rfc822"`

	// Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.
	GrantFullControl *string `location:"header" locationName:"x-amz-grant-full-control" type:"string"`

	// Allows grantee to read the object data and its metadata.
	GrantRead *string `location:"header" locationName:"x-amz-grant-read" type:"string"`

	// Allows grantee to read the object ACL.
	GrantReadACP *string `location:"header" locationName:"x-amz-grant-read-acp" type:"string"`

	// Allows grantee to write the ACL for the applicable object.
	GrantWriteACP *string `location:"header" locationName:"x-amz-grant-write-acp" type:"string"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// A map of metadata to store with the object in S3.
	Metadata map[string]*string `location:"headers" locationName:"x-amz-meta-" type:"map"`

	// Specifies whether the metadata is copied from the source object or replaced
	// with metadata provided in the request.
	MetadataDirective *string `location:"header" locationName:"x-amz-metadata-directive" type:"string"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// Specifies the AWS KMS key ID to use for object encryption. All GET and PUT
	// requests for an object protected by AWS KMS will fail if not made via SSL
	// or using SigV4. Documentation on configuring any of the officially supported
	// AWS SDKs and CLI can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// The type of storage to use for the object. Defaults to 'STANDARD'.
	StorageClass *string `location:"header" locationName:"x-amz-storage-class" type:"string"`

	// If the bucket is configured as a website, redirects requests for this object
	// to another object in the same bucket or to an external URL. Amazon S3 stores
	// the value of this header in the object metadata.
	WebsiteRedirectLocation *string `location:"header" locationName:"x-amz-website-redirect-location" type:"string"`

	metadataCopyObjectInput `json:"-" xml:"-"`
}

type metadataCopyObjectInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CopyObjectOutput struct {
	CopyObjectResult *CopyObjectResult `type:"structure"`

	CopySourceVersionID *string `location:"header" locationName:"x-amz-copy-source-version-id" type:"string"`

	// If the object expiration is configured, the response includes this header.
	Expiration *string `location:"header" locationName:"x-amz-expiration" type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	metadataCopyObjectOutput `json:"-" xml:"-"`
}

type metadataCopyObjectOutput struct {
	SDKShapeTraits bool `type:"structure" payload:"CopyObjectResult"`
}

type CopyObjectResult struct {
	ETag *string `type:"string"`

	LastModified *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	metadataCopyObjectResult `json:"-" xml:"-"`
}

type metadataCopyObjectResult struct {
	SDKShapeTraits bool `type:"structure"`
}

type CopyPartResult struct {
	// Entity tag of the object.
	ETag *string `type:"string"`

	// Date and time at which the object was uploaded.
	LastModified *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	metadataCopyPartResult `json:"-" xml:"-"`
}

type metadataCopyPartResult struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateBucketConfiguration struct {
	// Specifies the region where the bucket will be created. If you don't specify
	// a region, the bucket will be created in US Standard.
	LocationConstraint *string `type:"string"`

	metadataCreateBucketConfiguration `json:"-" xml:"-"`
}

type metadataCreateBucketConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateBucketInput struct {
	// The canned ACL to apply to the bucket.
	ACL *string `location:"header" locationName:"x-amz-acl" type:"string"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	CreateBucketConfiguration *CreateBucketConfiguration `locationName:"CreateBucketConfiguration" type:"structure" xmlURI:"http://s3.amazonaws.com/doc/2006-03-01/"`

	// Allows grantee the read, write, read ACP, and write ACP permissions on the
	// bucket.
	GrantFullControl *string `location:"header" locationName:"x-amz-grant-full-control" type:"string"`

	// Allows grantee to list the objects in the bucket.
	GrantRead *string `location:"header" locationName:"x-amz-grant-read" type:"string"`

	// Allows grantee to read the bucket ACL.
	GrantReadACP *string `location:"header" locationName:"x-amz-grant-read-acp" type:"string"`

	// Allows grantee to create, overwrite, and delete any object in the bucket.
	GrantWrite *string `location:"header" locationName:"x-amz-grant-write" type:"string"`

	// Allows grantee to write the ACL for the applicable bucket.
	GrantWriteACP *string `location:"header" locationName:"x-amz-grant-write-acp" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`


	MetadataCreateBucketInput `json:"-" xml:"-"`
}

type MetadataCreateBucketInput struct {
	SDKShapeTraits bool `type:"structure" payload:"CreateBucketConfiguration"`
}

type CreateBucketOutput struct {
	Location *string `location:"header" locationName:"Location" type:"string"`

	metadataCreateBucketOutput `json:"-" xml:"-"`
}

type metadataCreateBucketOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateMultipartUploadInput struct {
	// The canned ACL to apply to the object.
	ACL *string `location:"header" locationName:"x-amz-acl" type:"string"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Specifies caching behavior along the request/reply chain.
	CacheControl *string `location:"header" locationName:"Cache-Control" type:"string"`

	// Specifies presentational information for the object.
	ContentDisposition *string `location:"header" locationName:"Content-Disposition" type:"string"`

	// Specifies what content encodings have been applied to the object and thus
	// what decoding mechanisms must be applied to obtain the media-type referenced
	// by the Content-Type header field.
	ContentEncoding *string `location:"header" locationName:"Content-Encoding" type:"string"`

	// The language the content is in.
	ContentLanguage *string `location:"header" locationName:"Content-Language" type:"string"`

	// A standard MIME type describing the format of the object data.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// The date and time at which the object is no longer cacheable.
	Expires *time.Time `location:"header" locationName:"Expires" type:"timestamp" timestampFormat:"rfc822"`

	// Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.
	GrantFullControl *string `location:"header" locationName:"x-amz-grant-full-control" type:"string"`

	// Allows grantee to read the object data and its metadata.
	GrantRead *string `location:"header" locationName:"x-amz-grant-read" type:"string"`

	// Allows grantee to read the object ACL.
	GrantReadACP *string `location:"header" locationName:"x-amz-grant-read-acp" type:"string"`

	// Allows grantee to write the ACL for the applicable object.
	GrantWriteACP *string `location:"header" locationName:"x-amz-grant-write-acp" type:"string"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// A map of metadata to store with the object in S3.
	Metadata map[string]*string `location:"headers" locationName:"x-amz-meta-" type:"map"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// Specifies the AWS KMS key ID to use for object encryption. All GET and PUT
	// requests for an object protected by AWS KMS will fail if not made via SSL
	// or using SigV4. Documentation on configuring any of the officially supported
	// AWS SDKs and CLI can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// The type of storage to use for the object. Defaults to 'STANDARD'.
	StorageClass *string `location:"header" locationName:"x-amz-storage-class" type:"string"`

	// If the bucket is configured as a website, redirects requests for this object
	// to another object in the same bucket or to an external URL. Amazon S3 stores
	// the value of this header in the object metadata.
	WebsiteRedirectLocation *string `location:"header" locationName:"x-amz-website-redirect-location" type:"string"`

	metadataCreateMultipartUploadInput `json:"-" xml:"-"`
}

type metadataCreateMultipartUploadInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateMultipartUploadOutput struct {
	// Name of the bucket to which the multipart upload was initiated.
	Bucket *string `locationName:"Bucket" type:"string"`

	// Object key for which the multipart upload was initiated.
	Key *string `type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// ID for the initiated multipart upload.
	UploadID *string `locationName:"UploadId" type:"string"`

	metadataCreateMultipartUploadOutput `json:"-" xml:"-"`
}

type metadataCreateMultipartUploadOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type Delete struct {
	Objects []*ObjectIdentifier `locationName:"Object" type:"list" flattened:"true" required:"true"`

	// Element to enable quiet mode for the request. When you add this element,
	// you must set its value to true.
	Quiet *bool `type:"boolean"`

	metadataDelete `json:"-" xml:"-"`
}

type metadataDelete struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketCORSInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataDeleteBucketCORSInput `json:"-" xml:"-"`
}

type metadataDeleteBucketCORSInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketCORSOutput struct {
	metadataDeleteBucketCORSOutput `json:"-" xml:"-"`
}

type metadataDeleteBucketCORSOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataDeleteBucketInput `json:"-" xml:"-"`
}

type metadataDeleteBucketInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketLifecycleInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataDeleteBucketLifecycleInput `json:"-" xml:"-"`
}

type metadataDeleteBucketLifecycleInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketLifecycleOutput struct {
	metadataDeleteBucketLifecycleOutput `json:"-" xml:"-"`
}

type metadataDeleteBucketLifecycleOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketOutput struct {
	metadataDeleteBucketOutput `json:"-" xml:"-"`
}

type metadataDeleteBucketOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketPolicyInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataDeleteBucketPolicyInput `json:"-" xml:"-"`
}

type metadataDeleteBucketPolicyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketPolicyOutput struct {
	metadataDeleteBucketPolicyOutput `json:"-" xml:"-"`
}

type metadataDeleteBucketPolicyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketReplicationInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataDeleteBucketReplicationInput `json:"-" xml:"-"`
}

type metadataDeleteBucketReplicationInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketReplicationOutput struct {
	metadataDeleteBucketReplicationOutput `json:"-" xml:"-"`
}

type metadataDeleteBucketReplicationOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketTaggingInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataDeleteBucketTaggingInput `json:"-" xml:"-"`
}

type metadataDeleteBucketTaggingInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketTaggingOutput struct {
	metadataDeleteBucketTaggingOutput `json:"-" xml:"-"`
}

type metadataDeleteBucketTaggingOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketWebsiteInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataDeleteBucketWebsiteInput `json:"-" xml:"-"`
}

type metadataDeleteBucketWebsiteInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketWebsiteOutput struct {
	metadataDeleteBucketWebsiteOutput `json:"-" xml:"-"`
}

type metadataDeleteBucketWebsiteOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteMarkerEntry struct {
	// Specifies whether the object is (true) or is not (false) the latest version
	// of an object.
	IsLatest *bool `type:"boolean"`

	// The object key.
	Key *string `type:"string"`

	// Date and time the object was last modified.
	LastModified *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	Owner *Owner `type:"structure"`

	// Version ID of an object.
	VersionID *string `locationName:"VersionId" type:"string"`

	metadataDeleteMarkerEntry `json:"-" xml:"-"`
}

type metadataDeleteMarkerEntry struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteObjectInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// The concatenation of the authentication device's serial number, a space,
	// and the value that is displayed on your authentication device.
	MFA *string `location:"header" locationName:"x-amz-mfa" type:"string"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// VersionId used to reference a specific version of the object.
	VersionID *string `location:"querystring" locationName:"versionId" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataDeleteObjectInput `json:"-" xml:"-"`
}

type metadataDeleteObjectInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteObjectOutput struct {
	// Specifies whether the versioned object that was permanently deleted was (true)
	// or was not (false) a delete marker.
	DeleteMarker *bool `location:"header" locationName:"x-amz-delete-marker" type:"boolean"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// Returns the version ID of the delete marker created as a result of the DELETE
	// operation.
	VersionID *string `location:"header" locationName:"x-amz-version-id" type:"string"`

	metadataDeleteObjectOutput `json:"-" xml:"-"`
}

type metadataDeleteObjectOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteObjectsInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Delete *Delete `locationName:"Delete" type:"structure" required:"true"`

	// The concatenation of the authentication device's serial number, a space,
	// and the value that is displayed on your authentication device.
	MFA *string `location:"header" locationName:"x-amz-mfa" type:"string"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataDeleteObjectsInput `json:"-" xml:"-"`
}

type metadataDeleteObjectsInput struct {
	SDKShapeTraits bool `type:"structure" payload:"Delete"`
}

type DeleteObjectsOutput struct {
	Deleted []*DeletedObject `type:"list" flattened:"true"`

	Errors []*Error `locationName:"Error" type:"list" flattened:"true"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	metadataDeleteObjectsOutput `json:"-" xml:"-"`
}

type metadataDeleteObjectsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeletedObject struct {
	DeleteMarker *bool `type:"boolean"`

	DeleteMarkerVersionID *string `locationName:"DeleteMarkerVersionId" type:"string"`

	Key *string `type:"string"`

	VersionID *string `locationName:"VersionId" type:"string"`

	metadataDeletedObject `json:"-" xml:"-"`
}

type metadataDeletedObject struct {
	SDKShapeTraits bool `type:"structure"`
}

type Destination struct {
	// Amazon resource name (ARN) of the bucket where you want Amazon S3 to store
	// replicas of the object identified by the rule.
	Bucket *string `type:"string" required:"true"`

	metadataDestination `json:"-" xml:"-"`
}

type metadataDestination struct {
	SDKShapeTraits bool `type:"structure"`
}

type Error struct {
	Code *string `type:"string"`

	Key *string `type:"string"`

	Message *string `type:"string"`

	VersionID *string `locationName:"VersionId" type:"string"`

	metadataError `json:"-" xml:"-"`
}

type metadataError struct {
	SDKShapeTraits bool `type:"structure"`
}

type ErrorDocument struct {
	// The object key name to use when a 4XX class error occurs.
	Key *string `type:"string" required:"true"`

	metadataErrorDocument `json:"-" xml:"-"`
}

type metadataErrorDocument struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketACLInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataGetBucketACLInput `json:"-" xml:"-"`
}

type metadataGetBucketACLInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketACLOutput struct {
	// A list of grants.
	Grants []*Grant `locationName:"AccessControlList" locationNameList:"Grant" type:"list"`

	Owner *Owner `type:"structure"`

	metadataGetBucketACLOutput `json:"-" xml:"-"`
}

type metadataGetBucketACLOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketCORSInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataGetBucketCORSInput `json:"-" xml:"-"`
}

type metadataGetBucketCORSInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketCORSOutput struct {
	CORSRules []*CORSRule `locationName:"CORSRule" type:"list" flattened:"true"`

	metadataGetBucketCORSOutput `json:"-" xml:"-"`
}

type metadataGetBucketCORSOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketLifecycleInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataGetBucketLifecycleInput `json:"-" xml:"-"`
}

type metadataGetBucketLifecycleInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketLifecycleOutput struct {
	Rules []*LifecycleRule `locationName:"Rule" type:"list" flattened:"true"`

	metadataGetBucketLifecycleOutput `json:"-" xml:"-"`
}

type metadataGetBucketLifecycleOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketLocationInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataGetBucketLocationInput `json:"-" xml:"-"`
}

type metadataGetBucketLocationInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketLocationOutput struct {
	LocationConstraint *string `type:"string"`

	metadataGetBucketLocationOutput `json:"-" xml:"-"`
}

type metadataGetBucketLocationOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketLoggingInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataGetBucketLoggingInput `json:"-" xml:"-"`
}

type metadataGetBucketLoggingInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketLoggingOutput struct {
	LoggingEnabled *LoggingEnabled `type:"structure"`

	metadataGetBucketLoggingOutput `json:"-" xml:"-"`
}

type metadataGetBucketLoggingOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketNotificationConfigurationRequest struct {
	// Name of the buket to get the notification configuration for.
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	metadataGetBucketNotificationConfigurationRequest `json:"-" xml:"-"`
}

type metadataGetBucketNotificationConfigurationRequest struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketPolicyInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataGetBucketPolicyInput `json:"-" xml:"-"`
}

type metadataGetBucketPolicyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketPolicyOutput struct {
	// The bucket policy as a JSON document.
	Policy *string `type:"string"`

	metadataGetBucketPolicyOutput `json:"-" xml:"-"`
}

type metadataGetBucketPolicyOutput struct {
	SDKShapeTraits bool `type:"structure" payload:"Policy"`
}

type GetBucketReplicationInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataGetBucketReplicationInput `json:"-" xml:"-"`
}

type metadataGetBucketReplicationInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketReplicationOutput struct {
	// Container for replication rules. You can add as many as 1,000 rules. Total
	// replication configuration size can be up to 2 MB.
	ReplicationConfiguration *ReplicationConfiguration `type:"structure"`

	metadataGetBucketReplicationOutput `json:"-" xml:"-"`
}

type metadataGetBucketReplicationOutput struct {
	SDKShapeTraits bool `type:"structure" payload:"ReplicationConfiguration"`
}

type GetBucketRequestPaymentInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataGetBucketRequestPaymentInput `json:"-" xml:"-"`
}

type metadataGetBucketRequestPaymentInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketRequestPaymentOutput struct {
	// Specifies who pays for the download and request fees.
	Payer *string `type:"string"`

	metadataGetBucketRequestPaymentOutput `json:"-" xml:"-"`
}

type metadataGetBucketRequestPaymentOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketTaggingInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataGetBucketTaggingInput `json:"-" xml:"-"`
}

type metadataGetBucketTaggingInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketTaggingOutput struct {
	TagSet []*Tag `locationNameList:"Tag" type:"list" required:"true"`

	metadataGetBucketTaggingOutput `json:"-" xml:"-"`
}

type metadataGetBucketTaggingOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketVersioningInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataGetBucketVersioningInput `json:"-" xml:"-"`
}

type metadataGetBucketVersioningInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketVersioningOutput struct {
	// Specifies whether MFA delete is enabled in the bucket versioning configuration.
	// This element is only returned if the bucket has been configured with MFA
	// delete. If the bucket has never been so configured, this element is not returned.
	MFADelete *string `locationName:"MfaDelete" type:"string"`

	// The versioning state of the bucket.
	Status *string `type:"string"`

	metadataGetBucketVersioningOutput `json:"-" xml:"-"`
}

type metadataGetBucketVersioningOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketWebsiteInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataGetBucketWebsiteInput `json:"-" xml:"-"`
}

type metadataGetBucketWebsiteInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketWebsiteOutput struct {
	ErrorDocument *ErrorDocument `type:"structure"`

	IndexDocument *IndexDocument `type:"structure"`

	RedirectAllRequestsTo *RedirectAllRequestsTo `type:"structure"`

	RoutingRules []*RoutingRule `locationNameList:"RoutingRule" type:"list"`

	metadataGetBucketWebsiteOutput `json:"-" xml:"-"`
}

type metadataGetBucketWebsiteOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetObjectACLInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// VersionId used to reference a specific version of the object.
	VersionID *string `location:"querystring" locationName:"versionId" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataGetObjectACLInput `json:"-" xml:"-"`
}

type metadataGetObjectACLInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetObjectACLOutput struct {
	// A list of grants.
	Grants []*Grant `locationName:"AccessControlList" locationNameList:"Grant" type:"list"`

	Owner *Owner `type:"structure"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	metadataGetObjectACLOutput `json:"-" xml:"-"`
}

type metadataGetObjectACLOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetObjectInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Return the object only if its entity tag (ETag) is the same as the one specified,
	// otherwise return a 412 (precondition failed).
	IfMatch *string `location:"header" locationName:"If-Match" type:"string"`

	// Return the object only if it has been modified since the specified time,
	// otherwise return a 304 (not modified).
	IfModifiedSince *time.Time `location:"header" locationName:"If-Modified-Since" type:"timestamp" timestampFormat:"rfc822"`

	// Return the object only if its entity tag (ETag) is different from the one
	// specified, otherwise return a 304 (not modified).
	IfNoneMatch *string `location:"header" locationName:"If-None-Match" type:"string"`

	// Return the object only if it has not been modified since the specified time,
	// otherwise return a 412 (precondition failed).
	IfUnmodifiedSince *time.Time `location:"header" locationName:"If-Unmodified-Since" type:"timestamp" timestampFormat:"rfc822"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Downloads the specified range bytes of an object. For more information about
	// the HTTP Range header, go to http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.
	Range *string `location:"header" locationName:"Range" type:"string"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Sets the Cache-Control header of the response.
	ResponseCacheControl *string `location:"querystring" locationName:"response-cache-control" type:"string"`

	// Sets the Content-Disposition header of the response
	ResponseContentDisposition *string `location:"querystring" locationName:"response-content-disposition" type:"string"`

	// Sets the Content-Encoding header of the response.
	ResponseContentEncoding *string `location:"querystring" locationName:"response-content-encoding" type:"string"`

	// Sets the Content-Language header of the response.
	ResponseContentLanguage *string `location:"querystring" locationName:"response-content-language" type:"string"`

	// Sets the Content-Type header of the response.
	ResponseContentType *string `location:"querystring" locationName:"response-content-type" type:"string"`

	// Sets the Expires header of the response.
	ResponseExpires *time.Time `location:"querystring" locationName:"response-expires" type:"timestamp" timestampFormat:"iso8601"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// VersionId used to reference a specific version of the object.
	VersionID *string `location:"querystring" locationName:"versionId" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataGetObjectInput `json:"-" xml:"-"`
}

type metadataGetObjectInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetObjectOutput struct {
	AcceptRanges *string `location:"header" locationName:"accept-ranges" type:"string"`

	// Object data.
	Body io.ReadCloser `type:"blob"`

	// Specifies caching behavior along the request/reply chain.
	CacheControl *string `location:"header" locationName:"Cache-Control" type:"string"`

	// Specifies presentational information for the object.
	ContentDisposition *string `location:"header" locationName:"Content-Disposition" type:"string"`

	// Specifies what content encodings have been applied to the object and thus
	// what decoding mechanisms must be applied to obtain the media-type referenced
	// by the Content-Type header field.
	ContentEncoding *string `location:"header" locationName:"Content-Encoding" type:"string"`

	// The language the content is in.
	ContentLanguage *string `location:"header" locationName:"Content-Language" type:"string"`

	// Size of the body in bytes.
	ContentLength *int64 `location:"header" locationName:"Content-Length" type:"integer"`

	// The portion of the object returned in the response.
	ContentRange *string `location:"header" locationName:"Content-Range" type:"string"`

	// A standard MIME type describing the format of the object data.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Specifies whether the object retrieved was (true) or was not (false) a Delete
	// Marker. If false, this response header does not appear in the response.
	DeleteMarker *bool `location:"header" locationName:"x-amz-delete-marker" type:"boolean"`

	// An ETag is an opaque identifier assigned by a web server to a specific version
	// of a resource found at a URL
	ETag *string `location:"header" locationName:"ETag" type:"string"`

	// If the object expiration is configured (see PUT Bucket lifecycle), the response
	// includes this header. It includes the expiry-date and rule-id key value pairs
	// providing object expiration information. The value of the rule-id is URL
	// encoded.
	Expiration *string `location:"header" locationName:"x-amz-expiration" type:"string"`

	// The date and time at which the object is no longer cacheable.
	Expires *time.Time `location:"header" locationName:"Expires" type:"timestamp" timestampFormat:"rfc822"`

	// Last modified date of the object
	LastModified *time.Time `location:"header" locationName:"Last-Modified" type:"timestamp" timestampFormat:"rfc822"`

	// A map of metadata to store with the object in S3.
	Metadata map[string]*string `location:"headers" locationName:"x-amz-meta-" type:"map"`

	// This is set to the number of metadata entries not returned in x-amz-meta
	// headers. This can happen if you create metadata using an API like SOAP that
	// supports more flexible metadata than the REST API. For example, using SOAP,
	// you can create metadata whose values are not legal HTTP headers.
	MissingMeta *int64 `location:"header" locationName:"x-amz-missing-meta" type:"integer"`

	ReplicationStatus *string `location:"header" locationName:"x-amz-replication-status" type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// Provides information about object restoration operation and expiration time
	// of the restored object copy.
	Restore *string `location:"header" locationName:"x-amz-restore" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// Version of the object.
	VersionID *string `location:"header" locationName:"x-amz-version-id" type:"string"`

	// If the bucket is configured as a website, redirects requests for this object
	// to another object in the same bucket or to an external URL. Amazon S3 stores
	// the value of this header in the object metadata.
	WebsiteRedirectLocation *string `location:"header" locationName:"x-amz-website-redirect-location" type:"string"`

	metadataGetObjectOutput `json:"-" xml:"-"`
}

type metadataGetObjectOutput struct {
	SDKShapeTraits bool `type:"structure" payload:"Body"`
}

type GetObjectTorrentInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataGetObjectTorrentInput `json:"-" xml:"-"`
}

type metadataGetObjectTorrentInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetObjectTorrentOutput struct {
	Body io.ReadCloser `type:"blob"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	metadataGetObjectTorrentOutput `json:"-" xml:"-"`
}

type metadataGetObjectTorrentOutput struct {
	SDKShapeTraits bool `type:"structure" payload:"Body"`
}

type Grant struct {
	Grantee *Grantee `type:"structure"`

	// Specifies the permission given to the grantee.
	Permission *string `type:"string"`

	metadataGrant `json:"-" xml:"-"`
}

type metadataGrant struct {
	SDKShapeTraits bool `type:"structure"`
}

type Grantee struct {
	// Screen name of the grantee.
	DisplayName *string `type:"string"`

	// Email address of the grantee.
	EmailAddress *string `type:"string"`

	// The canonical user ID of the grantee.
	ID *string `type:"string"`

	// Type of grantee
	Type *string `locationName:"xsi:type" type:"string" xmlAttribute:"true" required:"true"`

	// URI of the grantee group.
	URI *string `type:"string"`

	metadataGrantee `json:"-" xml:"-"`
}

type metadataGrantee struct {
	SDKShapeTraits bool `type:"structure" xmlPrefix:"xsi" xmlURI:"http://www.w3.org/2001/XMLSchema-instance"`
}

type HeadBucketInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataHeadBucketInput `json:"-" xml:"-"`
}

type metadataHeadBucketInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type HeadBucketOutput struct {
	metadataHeadBucketOutput `json:"-" xml:"-"`
}

type metadataHeadBucketOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type HeadObjectInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Return the object only if its entity tag (ETag) is the same as the one specified,
	// otherwise return a 412 (precondition failed).
	IfMatch *string `location:"header" locationName:"If-Match" type:"string"`

	// Return the object only if it has been modified since the specified time,
	// otherwise return a 304 (not modified).
	IfModifiedSince *time.Time `location:"header" locationName:"If-Modified-Since" type:"timestamp" timestampFormat:"rfc822"`

	// Return the object only if its entity tag (ETag) is different from the one
	// specified, otherwise return a 304 (not modified).
	IfNoneMatch *string `location:"header" locationName:"If-None-Match" type:"string"`

	// Return the object only if it has not been modified since the specified time,
	// otherwise return a 412 (precondition failed).
	IfUnmodifiedSince *time.Time `location:"header" locationName:"If-Unmodified-Since" type:"timestamp" timestampFormat:"rfc822"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Downloads the specified range bytes of an object. For more information about
	// the HTTP Range header, go to http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.
	Range *string `location:"header" locationName:"Range" type:"string"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// VersionId used to reference a specific version of the object.
	VersionID *string `location:"querystring" locationName:"versionId" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataHeadObjectInput `json:"-" xml:"-"`
}

type metadataHeadObjectInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type HeadObjectOutput struct {
	AcceptRanges *string `location:"header" locationName:"accept-ranges" type:"string"`

	// Specifies caching behavior along the request/reply chain.
	CacheControl *string `location:"header" locationName:"Cache-Control" type:"string"`

	// Specifies presentational information for the object.
	ContentDisposition *string `location:"header" locationName:"Content-Disposition" type:"string"`

	// Specifies what content encodings have been applied to the object and thus
	// what decoding mechanisms must be applied to obtain the media-type referenced
	// by the Content-Type header field.
	ContentEncoding *string `location:"header" locationName:"Content-Encoding" type:"string"`

	// The language the content is in.
	ContentLanguage *string `location:"header" locationName:"Content-Language" type:"string"`

	// Size of the body in bytes.
	ContentLength *int64 `location:"header" locationName:"Content-Length" type:"integer"`

	// A standard MIME type describing the format of the object data.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Specifies whether the object retrieved was (true) or was not (false) a Delete
	// Marker. If false, this response header does not appear in the response.
	DeleteMarker *bool `location:"header" locationName:"x-amz-delete-marker" type:"boolean"`

	// An ETag is an opaque identifier assigned by a web server to a specific version
	// of a resource found at a URL
	ETag *string `location:"header" locationName:"ETag" type:"string"`

	// If the object expiration is configured (see PUT Bucket lifecycle), the response
	// includes this header. It includes the expiry-date and rule-id key value pairs
	// providing object expiration information. The value of the rule-id is URL
	// encoded.
	Expiration *string `location:"header" locationName:"x-amz-expiration" type:"string"`

	// The date and time at which the object is no longer cacheable.
	Expires *time.Time `location:"header" locationName:"Expires" type:"timestamp" timestampFormat:"rfc822"`

	// Last modified date of the object
	LastModified *time.Time `location:"header" locationName:"Last-Modified" type:"timestamp" timestampFormat:"rfc822"`

	// A map of metadata to store with the object in S3.
	Metadata map[string]*string `location:"headers" locationName:"x-amz-meta-" type:"map"`

	// This is set to the number of metadata entries not returned in x-amz-meta
	// headers. This can happen if you create metadata using an API like SOAP that
	// supports more flexible metadata than the REST API. For example, using SOAP,
	// you can create metadata whose values are not legal HTTP headers.
	MissingMeta *int64 `location:"header" locationName:"x-amz-missing-meta" type:"integer"`

	ReplicationStatus *string `location:"header" locationName:"x-amz-replication-status" type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// Provides information about object restoration operation and expiration time
	// of the restored object copy.
	Restore *string `location:"header" locationName:"x-amz-restore" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// Version of the object.
	VersionID *string `location:"header" locationName:"x-amz-version-id" type:"string"`

	// If the bucket is configured as a website, redirects requests for this object
	// to another object in the same bucket or to an external URL. Amazon S3 stores
	// the value of this header in the object metadata.
	WebsiteRedirectLocation *string `location:"header" locationName:"x-amz-website-redirect-location" type:"string"`

	metadataHeadObjectOutput `json:"-" xml:"-"`
}

type metadataHeadObjectOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type IndexDocument struct {
	// A suffix that is appended to a request that is for a directory on the website
	// endpoint (e.g. if the suffix is index.html and you make a request to samplebucket/images/
	// the data that is returned will be for the object with the key name images/index.html)
	// The suffix must not be empty and must not include a slash character.
	Suffix *string `type:"string" required:"true"`

	metadataIndexDocument `json:"-" xml:"-"`
}

type metadataIndexDocument struct {
	SDKShapeTraits bool `type:"structure"`
}

type Initiator struct {
	// Name of the Principal.
	DisplayName *string `type:"string"`

	// If the principal is an AWS account, it provides the Canonical User ID. If
	// the principal is an IAM User, it provides a user ARN value.
	ID *string `type:"string"`

	metadataInitiator `json:"-" xml:"-"`
}

type metadataInitiator struct {
	SDKShapeTraits bool `type:"structure"`
}

// Container for specifying the AWS Lambda notification configuration.
type LambdaFunctionConfiguration struct {
	Events []*string `locationName:"Event" type:"list" flattened:"true" required:"true"`

	// Optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	ID *string `locationName:"Id" type:"string"`

	// Lambda cloud function ARN that Amazon S3 can invoke when it detects events
	// of the specified type.
	LambdaFunctionARN *string `locationName:"CloudFunction" type:"string" required:"true"`

	metadataLambdaFunctionConfiguration `json:"-" xml:"-"`
}

type metadataLambdaFunctionConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type LifecycleConfiguration struct {
	Rules []*LifecycleRule `locationName:"Rule" type:"list" flattened:"true" required:"true"`

	metadataLifecycleConfiguration `json:"-" xml:"-"`
}

type metadataLifecycleConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type LifecycleExpiration struct {
	// Indicates at what date the object is to be moved or deleted. Should be in
	// GMT ISO 8601 Format.
	Date *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// Indicates the lifetime, in days, of the objects that are subject to the rule.
	// The value must be a non-zero positive integer.
	Days *int64 `type:"integer"`

	metadataLifecycleExpiration `json:"-" xml:"-"`
}

type metadataLifecycleExpiration struct {
	SDKShapeTraits bool `type:"structure"`
}

type LifecycleRule struct {
	Expiration *LifecycleExpiration `type:"structure"`

	// Unique identifier for the rule. The value cannot be longer than 255 characters.
	ID *string `type:"string"`

	// Specifies when noncurrent object versions expire. Upon expiration, Amazon
	// S3 permanently deletes the noncurrent object versions. You set this lifecycle
	// configuration action on a bucket that has versioning enabled (or suspended)
	// to request that Amazon S3 delete noncurrent object versions at a specific
	// period in the object's lifetime.
	NoncurrentVersionExpiration *NoncurrentVersionExpiration `type:"structure"`

	// Container for the transition rule that describes when noncurrent objects
	// transition to the GLACIER storage class. If your bucket is versioning-enabled
	// (or versioning is suspended), you can set this action to request that Amazon
	// S3 transition noncurrent object versions to the GLACIER storage class at
	// a specific period in the object's lifetime.
	NoncurrentVersionTransition *NoncurrentVersionTransition `type:"structure"`

	// Prefix identifying one or more objects to which the rule applies.
	Prefix *string `type:"string" required:"true"`

	// If 'Enabled', the rule is currently being applied. If 'Disabled', the rule
	// is not currently being applied.
	Status *string `type:"string" required:"true"`

	Transition *Transition `type:"structure"`

	metadataLifecycleRule `json:"-" xml:"-"`
}

type metadataLifecycleRule struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListBucketsInput struct {
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`
	metadataListBucketsInput `json:"-" xml:"-"`
}

type metadataListBucketsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListBucketsOutput struct {
	Buckets []*Bucket `locationNameList:"Bucket" type:"list"`

	Owner *Owner `type:"structure"`

	metadataListBucketsOutput `json:"-" xml:"-"`
}

type metadataListBucketsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListMultipartUploadsInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Character you use to group keys.
	Delimiter *string `location:"querystring" locationName:"delimiter" type:"string"`

	// Requests Amazon S3 to encode the object keys in the response and specifies
	// the encoding method to use. An object key may contain any Unicode character;
	// however, XML 1.0 parser cannot parse some characters, such as characters
	// with an ASCII value from 0 to 10. For characters that are not supported in
	// XML 1.0, you can add this parameter to request that Amazon S3 encode the
	// keys in the response.
	EncodingType *string `location:"querystring" locationName:"encoding-type" type:"string"`

	// Together with upload-id-marker, this parameter specifies the multipart upload
	// after which listing should begin.
	KeyMarker *string `location:"querystring" locationName:"key-marker" type:"string"`

	// Sets the maximum number of multipart uploads, from 1 to 1,000, to return
	// in the response body. 1,000 is the maximum number of uploads that can be
	// returned in a response.
	MaxUploads *int64 `location:"querystring" locationName:"max-uploads" type:"integer"`

	// Lists in-progress uploads only for those keys that begin with the specified
	// prefix.
	Prefix *string `location:"querystring" locationName:"prefix" type:"string"`

	// Together with key-marker, specifies the multipart upload after which listing
	// should begin. If key-marker is not specified, the upload-id-marker parameter
	// is ignored.
	UploadIDMarker *string `location:"querystring" locationName:"upload-id-marker" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataListMultipartUploadsInput `json:"-" xml:"-"`
}

type metadataListMultipartUploadsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListMultipartUploadsOutput struct {
	// Name of the bucket to which the multipart upload was initiated.
	Bucket *string `type:"string"`

	CommonPrefixes []*CommonPrefix `type:"list" flattened:"true"`

	Delimiter *string `type:"string"`

	// Encoding type used by Amazon S3 to encode object keys in the response.
	EncodingType *string `type:"string"`

	// Indicates whether the returned list of multipart uploads is truncated. A
	// value of true indicates that the list was truncated. The list can be truncated
	// if the number of multipart uploads exceeds the limit allowed or specified
	// by max uploads.
	IsTruncated *bool `type:"boolean"`

	// The key at or after which the listing began.
	KeyMarker *string `type:"string"`

	// Maximum number of multipart uploads that could have been included in the
	// response.
	MaxUploads *int64 `type:"integer"`

	// When a list is truncated, this element specifies the value that should be
	// used for the key-marker request parameter in a subsequent request.
	NextKeyMarker *string `type:"string"`

	// When a list is truncated, this element specifies the value that should be
	// used for the upload-id-marker request parameter in a subsequent request.
	NextUploadIDMarker *string `locationName:"NextUploadIdMarker" type:"string"`

	// When a prefix is provided in the request, this field contains the specified
	// prefix. The result contains only keys starting with the specified prefix.
	Prefix *string `type:"string"`

	// Upload ID after which listing began.
	UploadIDMarker *string `locationName:"UploadIdMarker" type:"string"`

	Uploads []*MultipartUpload `locationName:"Upload" type:"list" flattened:"true"`

	metadataListMultipartUploadsOutput `json:"-" xml:"-"`
}

type metadataListMultipartUploadsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListObjectVersionsInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// A delimiter is a character you use to group keys.
	Delimiter *string `location:"querystring" locationName:"delimiter" type:"string"`

	// Requests Amazon S3 to encode the object keys in the response and specifies
	// the encoding method to use. An object key may contain any Unicode character;
	// however, XML 1.0 parser cannot parse some characters, such as characters
	// with an ASCII value from 0 to 10. For characters that are not supported in
	// XML 1.0, you can add this parameter to request that Amazon S3 encode the
	// keys in the response.
	EncodingType *string `location:"querystring" locationName:"encoding-type" type:"string"`

	// Specifies the key to start with when listing objects in a bucket.
	KeyMarker *string `location:"querystring" locationName:"key-marker" type:"string"`

	// Sets the maximum number of keys returned in the response. The response might
	// contain fewer keys but will never contain more.
	MaxKeys *int64 `location:"querystring" locationName:"max-keys" type:"integer"`

	// Limits the response to keys that begin with the specified prefix.
	Prefix *string `location:"querystring" locationName:"prefix" type:"string"`

	// Specifies the object version you want to start listing from.
	VersionIDMarker *string `location:"querystring" locationName:"version-id-marker" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataListObjectVersionsInput `json:"-" xml:"-"`
}

type metadataListObjectVersionsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListObjectVersionsOutput struct {
	CommonPrefixes []*CommonPrefix `type:"list" flattened:"true"`

	DeleteMarkers []*DeleteMarkerEntry `locationName:"DeleteMarker" type:"list" flattened:"true"`

	Delimiter *string `type:"string"`

	// Encoding type used by Amazon S3 to encode object keys in the response.
	EncodingType *string `type:"string"`

	// A flag that indicates whether or not Amazon S3 returned all of the results
	// that satisfied the search criteria. If your results were truncated, you can
	// make a follow-up paginated request using the NextKeyMarker and NextVersionIdMarker
	// response parameters as a starting place in another request to return the
	// rest of the results.
	IsTruncated *bool `type:"boolean"`

	// Marks the last Key returned in a truncated response.
	KeyMarker *string `type:"string"`

	MaxKeys *int64 `type:"integer"`

	Name *string `type:"string"`

	// Use this value for the key marker request parameter in a subsequent request.
	NextKeyMarker *string `type:"string"`

	// Use this value for the next version id marker parameter in a subsequent request.
	NextVersionIDMarker *string `locationName:"NextVersionIdMarker" type:"string"`

	Prefix *string `type:"string"`

	VersionIDMarker *string `locationName:"VersionIdMarker" type:"string"`

	Versions []*ObjectVersion `locationName:"Version" type:"list" flattened:"true"`

	metadataListObjectVersionsOutput `json:"-" xml:"-"`
}

type metadataListObjectVersionsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListObjectsInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// A delimiter is a character you use to group keys.
	Delimiter *string `location:"querystring" locationName:"delimiter" type:"string"`

	// Requests Amazon S3 to encode the object keys in the response and specifies
	// the encoding method to use. An object key may contain any Unicode character;
	// however, XML 1.0 parser cannot parse some characters, such as characters
	// with an ASCII value from 0 to 10. For characters that are not supported in
	// XML 1.0, you can add this parameter to request that Amazon S3 encode the
	// keys in the response.
	EncodingType *string `location:"querystring" locationName:"encoding-type" type:"string"`

	// Specifies the key to start with when listing objects in a bucket.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// Sets the maximum number of keys returned in the response. The response might
	// contain fewer keys but will never contain more.
	MaxKeys *int64 `location:"querystring" locationName:"max-keys" type:"integer"`

	// Limits the response to keys that begin with the specified prefix.
	Prefix *string `location:"querystring" locationName:"prefix" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataListObjectsInput `json:"-" xml:"-"`
}

type metadataListObjectsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListObjectsOutput struct {
	CommonPrefixes []*CommonPrefix `type:"list" flattened:"true"`

	Contents []*Object `type:"list" flattened:"true"`

	Delimiter *string `type:"string"`

	// Encoding type used by Amazon S3 to encode object keys in the response.
	EncodingType *string `type:"string"`

	// A flag that indicates whether or not Amazon S3 returned all of the results
	// that satisfied the search criteria.
	IsTruncated *bool `type:"boolean"`

	Marker *string `type:"string"`

	MaxKeys *int64 `type:"integer"`

	Name *string `type:"string"`

	// When response is truncated (the IsTruncated element value in the response
	// is true), you can use the key name in this field as marker in the subsequent
	// request to get next set of objects. Amazon S3 lists objects in alphabetical
	// order Note: This element is returned only if you have delimiter request parameter
	// specified. If response does not include the NextMaker and it is truncated,
	// you can use the value of the last Key in the response as the marker in the
	// subsequent request to get the next set of object keys.
	NextMarker *string `type:"string"`

	Prefix *string `type:"string"`

	metadataListObjectsOutput `json:"-" xml:"-"`
}

type metadataListObjectsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListPartsInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Sets the maximum number of parts to return.
	MaxParts *int64 `location:"querystring" locationName:"max-parts" type:"integer"`

	// Specifies the part after which listing should begin. Only parts with higher
	// part numbers will be listed.
	PartNumberMarker *int64 `location:"querystring" locationName:"part-number-marker" type:"integer"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Upload ID identifying the multipart upload whose parts are being listed.
	UploadID *string `location:"querystring" locationName:"uploadId" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataListPartsInput `json:"-" xml:"-"`
}

type metadataListPartsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListPartsOutput struct {
	// Name of the bucket to which the multipart upload was initiated.
	Bucket *string `type:"string"`

	// Identifies who initiated the multipart upload.
	Initiator *Initiator `type:"structure"`

	// Indicates whether the returned list of parts is truncated.
	IsTruncated *bool `type:"boolean"`

	// Object key for which the multipart upload was initiated.
	Key *string `type:"string"`

	// Maximum number of parts that were allowed in the response.
	MaxParts *int64 `type:"integer"`

	// When a list is truncated, this element specifies the last part in the list,
	// as well as the value to use for the part-number-marker request parameter
	// in a subsequent request.
	NextPartNumberMarker *int64 `type:"integer"`

	Owner *Owner `type:"structure"`

	// Part number after which listing begins.
	PartNumberMarker *int64 `type:"integer"`

	Parts []*Part `locationName:"Part" type:"list" flattened:"true"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// The class of storage used to store the object.
	StorageClass *string `type:"string"`

	// Upload ID identifying the multipart upload whose parts are being listed.
	UploadID *string `locationName:"UploadId" type:"string"`

	metadataListPartsOutput `json:"-" xml:"-"`
}

type metadataListPartsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type LoggingEnabled struct {
	// Specifies the bucket where you want Amazon S3 to store server access logs.
	// You can have your logs delivered to any bucket that you own, including the
	// same bucket that is being logged. You can also configure multiple buckets
	// to deliver their logs to the same target bucket. In this case you should
	// choose a different TargetPrefix for each source bucket so that the delivered
	// log files can be distinguished by key.
	TargetBucket *string `type:"string"`

	TargetGrants []*TargetGrant `locationNameList:"Grant" type:"list"`

	// This element lets you specify a prefix for the keys that the log files will
	// be stored under.
	TargetPrefix *string `type:"string"`

	metadataLoggingEnabled `json:"-" xml:"-"`
}

type metadataLoggingEnabled struct {
	SDKShapeTraits bool `type:"structure"`
}

type MultipartUpload struct {
	// Date and time at which the multipart upload was initiated.
	Initiated *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// Identifies who initiated the multipart upload.
	Initiator *Initiator `type:"structure"`

	// Key of the object for which the multipart upload was initiated.
	Key *string `type:"string"`

	Owner *Owner `type:"structure"`

	// The class of storage used to store the object.
	StorageClass *string `type:"string"`

	// Upload ID that identifies the multipart upload.
	UploadID *string `locationName:"UploadId" type:"string"`

	metadataMultipartUpload `json:"-" xml:"-"`
}

type metadataMultipartUpload struct {
	SDKShapeTraits bool `type:"structure"`
}

// Specifies when noncurrent object versions expire. Upon expiration, Amazon
// S3 permanently deletes the noncurrent object versions. You set this lifecycle
// configuration action on a bucket that has versioning enabled (or suspended)
// to request that Amazon S3 delete noncurrent object versions at a specific
// period in the object's lifetime.
type NoncurrentVersionExpiration struct {
	// Specifies the number of days an object is noncurrent before Amazon S3 can
	// perform the associated action. For information about the noncurrent days
	// calculations, see How Amazon S3 Calculates When an Object Became Noncurrent
	// (/AmazonS3/latest/dev/s3-access-control.html) in the Amazon Simple Storage
	// Service Developer Guide.
	NoncurrentDays *int64 `type:"integer"`

	metadataNoncurrentVersionExpiration `json:"-" xml:"-"`
}

type metadataNoncurrentVersionExpiration struct {
	SDKShapeTraits bool `type:"structure"`
}

// Container for the transition rule that describes when noncurrent objects
// transition to the GLACIER storage class. If your bucket is versioning-enabled
// (or versioning is suspended), you can set this action to request that Amazon
// S3 transition noncurrent object versions to the GLACIER storage class at
// a specific period in the object's lifetime.
type NoncurrentVersionTransition struct {
	// Specifies the number of days an object is noncurrent before Amazon S3 can
	// perform the associated action. For information about the noncurrent days
	// calculations, see How Amazon S3 Calculates When an Object Became Noncurrent
	// (/AmazonS3/latest/dev/s3-access-control.html) in the Amazon Simple Storage
	// Service Developer Guide.
	NoncurrentDays *int64 `type:"integer"`

	// The class of storage used to store the object.
	StorageClass *string `type:"string"`

	metadataNoncurrentVersionTransition `json:"-" xml:"-"`
}

type metadataNoncurrentVersionTransition struct {
	SDKShapeTraits bool `type:"structure"`
}

// Container for specifying the notification configuration of the bucket. If
// this element is empty, notifications are turned off on the bucket.
type NotificationConfiguration struct {
	LambdaFunctionConfigurations []*LambdaFunctionConfiguration `locationName:"CloudFunctionConfiguration" type:"list" flattened:"true"`

	QueueConfigurations []*QueueConfiguration `locationName:"QueueConfiguration" type:"list" flattened:"true"`

	TopicConfigurations []*TopicConfiguration `locationName:"TopicConfiguration" type:"list" flattened:"true"`

	metadataNotificationConfiguration `json:"-" xml:"-"`
}

type metadataNotificationConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type NotificationConfigurationDeprecated struct {
	CloudFunctionConfiguration *CloudFunctionConfiguration `type:"structure"`

	QueueConfiguration *QueueConfigurationDeprecated `type:"structure"`

	TopicConfiguration *TopicConfigurationDeprecated `type:"structure"`

	metadataNotificationConfigurationDeprecated `json:"-" xml:"-"`
}

type metadataNotificationConfigurationDeprecated struct {
	SDKShapeTraits bool `type:"structure"`
}

type Object struct {
	ETag *string `type:"string"`

	Key *string `type:"string"`

	LastModified *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	Owner *Owner `type:"structure"`

	Size *int64 `type:"integer"`

	// The class of storage used to store the object.
	StorageClass *string `type:"string"`

	metadataObject `json:"-" xml:"-"`
}

type metadataObject struct {
	SDKShapeTraits bool `type:"structure"`
}

type ObjectIdentifier struct {
	// Key name of the object to delete.
	Key *string `type:"string" required:"true"`

	// VersionId for the specific version of the object to delete.
	VersionID *string `locationName:"VersionId" type:"string"`

	metadataObjectIdentifier `json:"-" xml:"-"`
}

type metadataObjectIdentifier struct {
	SDKShapeTraits bool `type:"structure"`
}

type ObjectVersion struct {
	ETag *string `type:"string"`

	// Specifies whether the object is (true) or is not (false) the latest version
	// of an object.
	IsLatest *bool `type:"boolean"`

	// The object key.
	Key *string `type:"string"`

	// Date and time the object was last modified.
	LastModified *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	Owner *Owner `type:"structure"`

	// Size in bytes of the object.
	Size *int64 `type:"integer"`

	// The class of storage used to store the object.
	StorageClass *string `type:"string"`

	// Version ID of an object.
	VersionID *string `locationName:"VersionId" type:"string"`

	metadataObjectVersion `json:"-" xml:"-"`
}

type metadataObjectVersion struct {
	SDKShapeTraits bool `type:"structure"`
}

type Owner struct {
	DisplayName *string `type:"string"`

	ID *string `type:"string"`

	metadataOwner `json:"-" xml:"-"`
}

type metadataOwner struct {
	SDKShapeTraits bool `type:"structure"`
}

type Part struct {
	// Entity tag returned when the part was uploaded.
	ETag *string `type:"string"`

	// Date and time at which the part was uploaded.
	LastModified *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// Part number identifying the part.
	PartNumber *int64 `type:"integer"`

	// Size of the uploaded part data.
	Size *int64 `type:"integer"`

	metadataPart `json:"-" xml:"-"`
}

type metadataPart struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketACLInput struct {
	// The canned ACL to apply to the bucket.
	ACL *string `location:"header" locationName:"x-amz-acl" type:"string"`

	AccessControlPolicy *AccessControlPolicy `locationName:"AccessControlPolicy" type:"structure"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Allows grantee the read, write, read ACP, and write ACP permissions on the
	// bucket.
	GrantFullControl *string `location:"header" locationName:"x-amz-grant-full-control" type:"string"`

	// Allows grantee to list the objects in the bucket.
	GrantRead *string `location:"header" locationName:"x-amz-grant-read" type:"string"`

	// Allows grantee to read the bucket ACL.
	GrantReadACP *string `location:"header" locationName:"x-amz-grant-read-acp" type:"string"`

	// Allows grantee to create, overwrite, and delete any object in the bucket.
	GrantWrite *string `location:"header" locationName:"x-amz-grant-write" type:"string"`

	// Allows grantee to write the ACL for the applicable bucket.
	GrantWriteACP *string `location:"header" locationName:"x-amz-grant-write-acp" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataPutBucketACLInput `json:"-" xml:"-"`
}

type metadataPutBucketACLInput struct {
	SDKShapeTraits bool `type:"structure" payload:"AccessControlPolicy"`
}

type PutBucketACLOutput struct {
	metadataPutBucketACLOutput `json:"-" xml:"-"`
}

type metadataPutBucketACLOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketCORSInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	CORSConfiguration *CORSConfiguration `locationName:"CORSConfiguration" type:"structure"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataPutBucketCORSInput `json:"-" xml:"-"`
}

type metadataPutBucketCORSInput struct {
	SDKShapeTraits bool `type:"structure" payload:"CORSConfiguration"`
}

type PutBucketCORSOutput struct {
	metadataPutBucketCORSOutput `json:"-" xml:"-"`
}

type metadataPutBucketCORSOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketLifecycleInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	LifecycleConfiguration *LifecycleConfiguration `locationName:"LifecycleConfiguration" type:"structure"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataPutBucketLifecycleInput `json:"-" xml:"-"`
}

type metadataPutBucketLifecycleInput struct {
	SDKShapeTraits bool `type:"structure" payload:"LifecycleConfiguration"`
}

type PutBucketLifecycleOutput struct {
	metadataPutBucketLifecycleOutput `json:"-" xml:"-"`
}

type metadataPutBucketLifecycleOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketLoggingInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	BucketLoggingStatus *BucketLoggingStatus `locationName:"BucketLoggingStatus" type:"structure" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataPutBucketLoggingInput `json:"-" xml:"-"`
}

type metadataPutBucketLoggingInput struct {
	SDKShapeTraits bool `type:"structure" payload:"BucketLoggingStatus"`
}

type PutBucketLoggingOutput struct {
	metadataPutBucketLoggingOutput `json:"-" xml:"-"`
}

type metadataPutBucketLoggingOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketNotificationConfigurationInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Container for specifying the notification configuration of the bucket. If
	// this element is empty, notifications are turned off on the bucket.
	NotificationConfiguration *NotificationConfiguration `locationName:"NotificationConfiguration" type:"structure" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataPutBucketNotificationConfigurationInput `json:"-" xml:"-"`
}

type metadataPutBucketNotificationConfigurationInput struct {
	SDKShapeTraits bool `type:"structure" payload:"NotificationConfiguration"`
}

type PutBucketNotificationConfigurationOutput struct {
	metadataPutBucketNotificationConfigurationOutput `json:"-" xml:"-"`
}

type metadataPutBucketNotificationConfigurationOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketNotificationInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	NotificationConfiguration *NotificationConfigurationDeprecated `locationName:"NotificationConfiguration" type:"structure" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataPutBucketNotificationInput `json:"-" xml:"-"`
}

type metadataPutBucketNotificationInput struct {
	SDKShapeTraits bool `type:"structure" payload:"NotificationConfiguration"`
}

type PutBucketNotificationOutput struct {
	metadataPutBucketNotificationOutput `json:"-" xml:"-"`
}

type metadataPutBucketNotificationOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketPolicyInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// The bucket policy as a JSON document.
	Policy *string `type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataPutBucketPolicyInput `json:"-" xml:"-"`
}

type metadataPutBucketPolicyInput struct {
	SDKShapeTraits bool `type:"structure" payload:"Policy"`
}

type PutBucketPolicyOutput struct {
	metadataPutBucketPolicyOutput `json:"-" xml:"-"`
}

type metadataPutBucketPolicyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketReplicationInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Container for replication rules. You can add as many as 1,000 rules. Total
	// replication configuration size can be up to 2 MB.
	ReplicationConfiguration *ReplicationConfiguration `locationName:"ReplicationConfiguration" type:"structure" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataPutBucketReplicationInput `json:"-" xml:"-"`
}

type metadataPutBucketReplicationInput struct {
	SDKShapeTraits bool `type:"structure" payload:"ReplicationConfiguration"`
}

type PutBucketReplicationOutput struct {
	metadataPutBucketReplicationOutput `json:"-" xml:"-"`
}

type metadataPutBucketReplicationOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketRequestPaymentInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	RequestPaymentConfiguration *RequestPaymentConfiguration `locationName:"RequestPaymentConfiguration" type:"structure" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataPutBucketRequestPaymentInput `json:"-" xml:"-"`
}

type metadataPutBucketRequestPaymentInput struct {
	SDKShapeTraits bool `type:"structure" payload:"RequestPaymentConfiguration"`
}

type PutBucketRequestPaymentOutput struct {
	metadataPutBucketRequestPaymentOutput `json:"-" xml:"-"`
}

type metadataPutBucketRequestPaymentOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketTaggingInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Tagging *Tagging `locationName:"Tagging" type:"structure" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataPutBucketTaggingInput `json:"-" xml:"-"`
}

type metadataPutBucketTaggingInput struct {
	SDKShapeTraits bool `type:"structure" payload:"Tagging"`
}

type PutBucketTaggingOutput struct {
	metadataPutBucketTaggingOutput `json:"-" xml:"-"`
}

type metadataPutBucketTaggingOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketVersioningInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// The concatenation of the authentication device's serial number, a space,
	// and the value that is displayed on your authentication device.
	MFA *string `location:"header" locationName:"x-amz-mfa" type:"string"`

	VersioningConfiguration *VersioningConfiguration `locationName:"VersioningConfiguration" type:"structure" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataPutBucketVersioningInput `json:"-" xml:"-"`
}

type metadataPutBucketVersioningInput struct {
	SDKShapeTraits bool `type:"structure" payload:"VersioningConfiguration"`
}

type PutBucketVersioningOutput struct {
	metadataPutBucketVersioningOutput `json:"-" xml:"-"`
}

type metadataPutBucketVersioningOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketWebsiteInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	WebsiteConfiguration *WebsiteConfiguration `locationName:"WebsiteConfiguration" type:"structure" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataPutBucketWebsiteInput `json:"-" xml:"-"`
}

type metadataPutBucketWebsiteInput struct {
	SDKShapeTraits bool `type:"structure" payload:"WebsiteConfiguration"`
}

type PutBucketWebsiteOutput struct {
	metadataPutBucketWebsiteOutput `json:"-" xml:"-"`
}

type metadataPutBucketWebsiteOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutObjectACLInput struct {
	// The canned ACL to apply to the object.
	ACL *string `location:"header" locationName:"x-amz-acl" type:"string"`

	AccessControlPolicy *AccessControlPolicy `locationName:"AccessControlPolicy" type:"structure"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Allows grantee the read, write, read ACP, and write ACP permissions on the
	// bucket.
	GrantFullControl *string `location:"header" locationName:"x-amz-grant-full-control" type:"string"`

	// Allows grantee to list the objects in the bucket.
	GrantRead *string `location:"header" locationName:"x-amz-grant-read" type:"string"`

	// Allows grantee to read the bucket ACL.
	GrantReadACP *string `location:"header" locationName:"x-amz-grant-read-acp" type:"string"`

	// Allows grantee to create, overwrite, and delete any object in the bucket.
	GrantWrite *string `location:"header" locationName:"x-amz-grant-write" type:"string"`

	// Allows grantee to write the ACL for the applicable bucket.
	GrantWriteACP *string `location:"header" locationName:"x-amz-grant-write-acp" type:"string"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataPutObjectACLInput `json:"-" xml:"-"`
}

type metadataPutObjectACLInput struct {
	SDKShapeTraits bool `type:"structure" payload:"AccessControlPolicy"`
}

type PutObjectACLOutput struct {
	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	metadataPutObjectACLOutput `json:"-" xml:"-"`
}

type metadataPutObjectACLOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutObjectInput struct {
	// The canned ACL to apply to the object.
	ACL *string `location:"header" locationName:"x-amz-acl" type:"string"`

	// Object data.
	Body io.ReadSeeker `type:"blob"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Specifies caching behavior along the request/reply chain.
	CacheControl *string `location:"header" locationName:"Cache-Control" type:"string"`

	// Specifies presentational information for the object.
	ContentDisposition *string `location:"header" locationName:"Content-Disposition" type:"string"`

	// Specifies what content encodings have been applied to the object and thus
	// what decoding mechanisms must be applied to obtain the media-type referenced
	// by the Content-Type header field.
	ContentEncoding *string `location:"header" locationName:"Content-Encoding" type:"string"`

	// The language the content is in.
	ContentLanguage *string `location:"header" locationName:"Content-Language" type:"string"`

	// Size of the body in bytes. This parameter is useful when the size of the
	// body cannot be determined automatically.
	ContentLength *int64 `location:"header" locationName:"Content-Length" type:"integer"`

	// A standard MIME type describing the format of the object data.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// The date and time at which the object is no longer cacheable.
	Expires *time.Time `location:"header" locationName:"Expires" type:"timestamp" timestampFormat:"rfc822"`

	// Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.
	GrantFullControl *string `location:"header" locationName:"x-amz-grant-full-control" type:"string"`

	// Allows grantee to read the object data and its metadata.
	GrantRead *string `location:"header" locationName:"x-amz-grant-read" type:"string"`

	// Allows grantee to read the object ACL.
	GrantReadACP *string `location:"header" locationName:"x-amz-grant-read-acp" type:"string"`

	// Allows grantee to write the ACL for the applicable object.
	GrantWriteACP *string `location:"header" locationName:"x-amz-grant-write-acp" type:"string"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// A map of metadata to store with the object in S3.
	Metadata map[string]*string `location:"headers" locationName:"x-amz-meta-" type:"map"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// Specifies the AWS KMS key ID to use for object encryption. All GET and PUT
	// requests for an object protected by AWS KMS will fail if not made via SSL
	// or using SigV4. Documentation on configuring any of the officially supported
	// AWS SDKs and CLI can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// The type of storage to use for the object. Defaults to 'STANDARD'.
	StorageClass *string `location:"header" locationName:"x-amz-storage-class" type:"string"`

	// If the bucket is configured as a website, redirects requests for this object
	// to another object in the same bucket or to an external URL. Amazon S3 stores
	// the value of this header in the object metadata.
	WebsiteRedirectLocation *string `location:"header" locationName:"x-amz-website-redirect-location" type:"string"`

	ContentMaxLength *int64 `location:"header" locationName:"x-amz-content-maxlength" type:"integer"`

	metadataPutObjectInput `json:"-" xml:"-"`
}

type metadataPutObjectInput struct {
	SDKShapeTraits bool `type:"structure" payload:"Body"`
}

type PutObjectOutput struct {
	// Entity tag for the uploaded object.
	ETag *string `location:"header" locationName:"ETag" type:"string"`

	// If the object expiration is configured, this will contain the expiration
	// date (expiry-date) and rule ID (rule-id). The value of rule-id is URL encoded.
	Expiration *string `location:"header" locationName:"x-amz-expiration" type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// Version of the object.
	VersionID *string `location:"header" locationName:"x-amz-version-id" type:"string"`

	NewFileName *string `location:"header" locationName:"newfilename" type:"string"`

	metadataPutObjectOutput `json:"-" xml:"-"`
}

type metadataPutObjectOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Container for specifying an configuration when you want Amazon S3 to publish
// events to an Amazon Simple Queue Service (Amazon SQS) queue.
type QueueConfiguration struct {
	Events []*string `locationName:"Event" type:"list" flattened:"true" required:"true"`

	// Optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	ID *string `locationName:"Id" type:"string"`

	// Amazon SQS queue ARN to which Amazon S3 will publish a message when it detects
	// events of specified type.
	QueueARN *string `locationName:"Queue" type:"string" required:"true"`

	metadataQueueConfiguration `json:"-" xml:"-"`
}

type metadataQueueConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type QueueConfigurationDeprecated struct {
	// Bucket event for which to send notifications.
	Event *string `type:"string"`

	Events []*string `locationName:"Event" type:"list" flattened:"true"`

	// Optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	ID *string `locationName:"Id" type:"string"`

	Queue *string `type:"string"`

	metadataQueueConfigurationDeprecated `json:"-" xml:"-"`
}

type metadataQueueConfigurationDeprecated struct {
	SDKShapeTraits bool `type:"structure"`
}

type Redirect struct {
	// The HTTP redirect code to use on the response. Not required if one of the
	// siblings is present.
	HTTPRedirectCode *string `locationName:"HttpRedirectCode" type:"string"`

	// The host name to use in the redirect request.
	HostName *string `type:"string"`

	// Protocol to use (http, https) when redirecting requests. The default is the
	// protocol that is used in the original request.
	Protocol *string `type:"string"`

	// The object key prefix to use in the redirect request. For example, to redirect
	// requests for all pages with prefix docs/ (objects in the docs/ folder) to
	// documents/, you can set a condition block with KeyPrefixEquals set to docs/
	// and in the Redirect set ReplaceKeyPrefixWith to /documents. Not required
	// if one of the siblings is present. Can be present only if ReplaceKeyWith
	// is not provided.
	ReplaceKeyPrefixWith *string `type:"string"`

	// The specific object key to use in the redirect request. For example, redirect
	// request to error.html. Not required if one of the sibling is present. Can
	// be present only if ReplaceKeyPrefixWith is not provided.
	ReplaceKeyWith *string `type:"string"`

	metadataRedirect `json:"-" xml:"-"`
}

type metadataRedirect struct {
	SDKShapeTraits bool `type:"structure"`
}

type RedirectAllRequestsTo struct {
	// Name of the host where requests will be redirected.
	HostName *string `type:"string" required:"true"`

	// Protocol to use (http, https) when redirecting requests. The default is the
	// protocol that is used in the original request.
	Protocol *string `type:"string"`

	metadataRedirectAllRequestsTo `json:"-" xml:"-"`
}

type metadataRedirectAllRequestsTo struct {
	SDKShapeTraits bool `type:"structure"`
}

// Container for replication rules. You can add as many as 1,000 rules. Total
// replication configuration size can be up to 2 MB.
type ReplicationConfiguration struct {
	// Amazon Resource Name (ARN) of an IAM role for Amazon S3 to assume when replicating
	// the objects.
	Role *string `type:"string" required:"true"`

	// Container for information about a particular replication rule. Replication
	// configuration must have at least one rule and can contain up to 1,000 rules.
	Rules []*ReplicationRule `locationName:"Rule" type:"list" flattened:"true" required:"true"`

	metadataReplicationConfiguration `json:"-" xml:"-"`
}

type metadataReplicationConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type ReplicationRule struct {
	Destination *Destination `type:"structure" required:"true"`

	// Unique identifier for the rule. The value cannot be longer than 255 characters.
	ID *string `type:"string"`

	// Object keyname prefix identifying one or more objects to which the rule applies.
	// Maximum prefix length can be up to 1,024 characters. Overlapping prefixes
	// are not supported.
	Prefix *string `type:"string" required:"true"`

	// The rule is ignored if status is not Enabled.
	Status *string `type:"string" required:"true"`

	metadataReplicationRule `json:"-" xml:"-"`
}

type metadataReplicationRule struct {
	SDKShapeTraits bool `type:"structure"`
}

type RequestPaymentConfiguration struct {
	// Specifies who pays for the download and request fees.
	Payer *string `type:"string" required:"true"`

	metadataRequestPaymentConfiguration `json:"-" xml:"-"`
}

type metadataRequestPaymentConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type RestoreObjectInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	RestoreRequest *RestoreRequest `locationName:"RestoreRequest" type:"structure"`

	VersionID *string `location:"querystring" locationName:"versionId" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataRestoreObjectInput `json:"-" xml:"-"`
}

type metadataRestoreObjectInput struct {
	SDKShapeTraits bool `type:"structure" payload:"RestoreRequest"`
}

type RestoreObjectOutput struct {
	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	metadataRestoreObjectOutput `json:"-" xml:"-"`
}

type metadataRestoreObjectOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type RestoreRequest struct {
	// Lifetime of the active copy in days
	Days *int64 `type:"integer" required:"true"`

	metadataRestoreRequest `json:"-" xml:"-"`
}

type metadataRestoreRequest struct {
	SDKShapeTraits bool `type:"structure"`
}

type RoutingRule struct {
	// A container for describing a condition that must be met for the specified
	// redirect to apply. For example, 1. If request is for pages in the /docs folder,
	// redirect to the /documents folder. 2. If request results in HTTP error 4xx,
	// redirect request to another host where you might process the error.
	Condition *Condition `type:"structure"`

	// Container for redirect information. You can redirect requests to another
	// host, to another page, or with another protocol. In the event of an error,
	// you can can specify a different error code to return.
	Redirect *Redirect `type:"structure" required:"true"`

	metadataRoutingRule `json:"-" xml:"-"`
}

type metadataRoutingRule struct {
	SDKShapeTraits bool `type:"structure"`
}

type Tag struct {
	// Name of the tag.
	Key *string `type:"string" required:"true"`

	// Value of the tag.
	Value *string `type:"string" required:"true"`

	metadataTag `json:"-" xml:"-"`
}

type metadataTag struct {
	SDKShapeTraits bool `type:"structure"`
}

type Tagging struct {
	TagSet []*Tag `locationNameList:"Tag" type:"list" required:"true"`

	metadataTagging `json:"-" xml:"-"`
}

type metadataTagging struct {
	SDKShapeTraits bool `type:"structure"`
}

type TargetGrant struct {
	Grantee *Grantee `type:"structure"`

	// Logging permissions assigned to the Grantee for the bucket.
	Permission *string `type:"string"`

	metadataTargetGrant `json:"-" xml:"-"`
}

type metadataTargetGrant struct {
	SDKShapeTraits bool `type:"structure"`
}

// Container for specifying the configuration when you want Amazon S3 to publish
// events to an Amazon Simple Notification Service (Amazon SNS) topic.
type TopicConfiguration struct {
	Events []*string `locationName:"Event" type:"list" flattened:"true" required:"true"`

	// Optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	ID *string `locationName:"Id" type:"string"`

	// Amazon SNS topic ARN to which Amazon S3 will publish a message when it detects
	// events of specified type.
	TopicARN *string `locationName:"Topic" type:"string" required:"true"`

	metadataTopicConfiguration `json:"-" xml:"-"`
}

type metadataTopicConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type TopicConfigurationDeprecated struct {
	// Bucket event for which to send notifications.
	Event *string `type:"string"`

	Events []*string `locationName:"Event" type:"list" flattened:"true"`

	// Optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	ID *string `locationName:"Id" type:"string"`

	// Amazon SNS topic to which Amazon S3 will publish a message to report the
	// specified events for the bucket.
	Topic *string `type:"string"`

	metadataTopicConfigurationDeprecated `json:"-" xml:"-"`
}

type metadataTopicConfigurationDeprecated struct {
	SDKShapeTraits bool `type:"structure"`
}

type Transition struct {
	// Indicates at what date the object is to be moved or deleted. Should be in
	// GMT ISO 8601 Format.
	Date *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// Indicates the lifetime, in days, of the objects that are subject to the rule.
	// The value must be a non-zero positive integer.
	Days *int64 `type:"integer"`

	// The class of storage used to store the object.
	StorageClass *string `type:"string"`

	metadataTransition `json:"-" xml:"-"`
}

type metadataTransition struct {
	SDKShapeTraits bool `type:"structure"`
}

type UploadPartCopyInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// The name of the source bucket and key name of the source object, separated
	// by a slash (/). Must be URL-encoded.
	CopySource *string `location:"header" locationName:"x-amz-copy-source" type:"string" required:"true"`

	// Copies the object if its entity tag (ETag) matches the specified tag.
	CopySourceIfMatch *string `location:"header" locationName:"x-amz-copy-source-if-match" type:"string"`

	// Copies the object if it has been modified since the specified time.
	CopySourceIfModifiedSince *time.Time `location:"header" locationName:"x-amz-copy-source-if-modified-since" type:"timestamp" timestampFormat:"rfc822"`

	// Copies the object if its entity tag (ETag) is different than the specified
	// ETag.
	CopySourceIfNoneMatch *string `location:"header" locationName:"x-amz-copy-source-if-none-match" type:"string"`

	// Copies the object if it hasn't been modified since the specified time.
	CopySourceIfUnmodifiedSince *time.Time `location:"header" locationName:"x-amz-copy-source-if-unmodified-since" type:"timestamp" timestampFormat:"rfc822"`

	// The range of bytes to copy from the source object. The range value must use
	// the form bytes=first-last, where the first and last are the zero-based byte
	// offsets to copy. For example, bytes=0-9 indicates that you want to copy the
	// first ten bytes of the source. You can copy a range only if the source object
	// is greater than 5 GB.
	CopySourceRange *string `location:"header" locationName:"x-amz-copy-source-range" type:"string"`

	// Specifies the algorithm to use when decrypting the source object (e.g., AES256).
	CopySourceSSECustomerAlgorithm *string `location:"header" locationName:"x-amz-copy-source-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use to decrypt
	// the source object. The encryption key provided in this header must be one
	// that was used when the source object was created.
	CopySourceSSECustomerKey *string `location:"header" locationName:"x-amz-copy-source-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	CopySourceSSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-copy-source-server-side-encryption-customer-key-MD5" type:"string"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Part number of part being copied.
	PartNumber *int64 `location:"querystring" locationName:"partNumber" type:"integer" required:"true"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header. This must be the same encryption key specified in the initiate multipart
	// upload request.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// Upload ID identifying the multipart upload whose part is being copied.
	UploadID *string `location:"querystring" locationName:"uploadId" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataUploadPartCopyInput `json:"-" xml:"-"`
}

type metadataUploadPartCopyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type UploadPartCopyOutput struct {
	CopyPartResult *CopyPartResult `type:"structure"`

	// The version of the source object that was copied, if you have enabled versioning
	// on the source bucket.
	CopySourceVersionID *string `location:"header" locationName:"x-amz-copy-source-version-id" type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	metadataUploadPartCopyOutput `json:"-" xml:"-"`
}

type metadataUploadPartCopyOutput struct {
	SDKShapeTraits bool `type:"structure" payload:"CopyPartResult"`
}

type UploadPartInput struct {
	Body io.ReadSeeker `type:"blob"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Size of the body in bytes. This parameter is useful when the size of the
	// body cannot be determined automatically.
	ContentLength *int64 `location:"header" locationName:"Content-Length" type:"integer"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Part number of part being uploaded.
	PartNumber *int64 `location:"querystring" locationName:"partNumber" type:"integer" required:"true"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header. This must be the same encryption key specified in the initiate multipart
	// upload request.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// Upload ID identifying the multipart upload whose part is being uploaded.
	UploadID *string `location:"querystring" locationName:"uploadId" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	metadataUploadPartInput `json:"-" xml:"-"`
}

type metadataUploadPartInput struct {
	SDKShapeTraits bool `type:"structure" payload:"Body"`
}

type UploadPartOutput struct {
	// Entity tag for the uploaded object.
	ETag *string `location:"header" locationName:"ETag" type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	metadataUploadPartOutput `json:"-" xml:"-"`
}

type metadataUploadPartOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type VersioningConfiguration struct {
	// Specifies whether MFA delete is enabled in the bucket versioning configuration.
	// This element is only returned if the bucket has been configured with MFA
	// delete. If the bucket has never been so configured, this element is not returned.
	MFADelete *string `locationName:"MfaDelete" type:"string"`

	// The versioning state of the bucket.
	Status *string `type:"string"`

	metadataVersioningConfiguration `json:"-" xml:"-"`
}

type metadataVersioningConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type WebsiteConfiguration struct {
	ErrorDocument *ErrorDocument `type:"structure"`

	IndexDocument *IndexDocument `type:"structure"`

	RedirectAllRequestsTo *RedirectAllRequestsTo `type:"structure"`

	RoutingRules []*RoutingRule `locationNameList:"RoutingRule" type:"list"`

	metadataWebsiteConfiguration `json:"-" xml:"-"`
}

type metadataWebsiteConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}
