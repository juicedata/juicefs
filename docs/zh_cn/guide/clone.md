---
title: 克隆文件或目录
sidebar_position: 6
---

对指定数据进行克隆，创建克隆时不会实际拷贝对象存储数据，而是仅拷贝元数据，因此不论对多大的文件或目录进行克隆，都非常快。对于 JuiceFS，这个命令是 `cp` 更好的替代，甚至对于 Linux 客户端来说，如果所使用的内核支持 [`copy_file_range`](https://man7.org/linux/man-pages/man2/copy_file_range.2.html)，那么调用 `cp` 时，实际发生的也是同样的元数据拷贝，调用将会格外迅速。

![clone](../images/juicefs-clone.svg)

克隆结果是纯粹的元数据拷贝，实际引用的对象存储块和源文件相同，因此在各方面都和源文件一样，可以正常读写。有任何一方文件数据被实际修改时，对应的数据块变更会以写入时复制（Copy-on-Write）的方式，写入到新的数据块，而其他未经修改的文件区域，由于对象存储数据块仍然相同，所以引用关系依然保持不变。

需要注意的是，**克隆产生的元数据，也同样占用文件系统存储空间，以及元数据引擎的存储空间**，因此对庞大的目录进行克隆操作时请格外谨慎。

```shell
juicefs clone SRC DST

# 克隆文件
juicefs clone /mnt/jfs/file1 /mnt/jfs/file2

# 克隆目录
juicefs clone /mnt/jfs/dir1 /mnt/jfs/dir2
```

## 一致性 {#consistency}

在事务一致性方面，克隆的行为如下：

- 在 `clone` 命令完成前，目标目录不可见。
- 对于文件：`clone` 命令确保原子性，即克隆后的文件始终处于正确和一致的状态。
- 对于目录：`clone` 命令对目录的原子性没有保证。换句话说，在克隆过程中，如果源目录发生变化，则目标目录与源目录可能不一致。

考虑到单个文件的克隆具有原子性，如果多个进程同时克隆到同一目标端，最终只会有一个克隆能够成功。具体而言，有多少个克隆任务，任务执行期间就会有多少棵独立的未完成的元数据子树（顶节点 inode 不同）。克隆到了创建最终的目标端的子树时，会检查唯一的目标边是否存在，存在则该克隆进程失败。不存在则原子地建立该边。不难想象，多个目的地相同的克隆进程，最终只会成功一个。

上边谈到克隆命令可能会失败，失败可能会造成元数据泄漏，可以通过 [`juicefs gc --delete`](../reference/command_reference.md#gc) 清理这些垃圾数据。

具体而言，克隆子树的过程中如果发生异常，程序会尝试同步清理已创建好的子树，考虑到清理过程也有可能出现异常，分情况讨论：

1. 克隆子树失败，但清理工作成功。此时子树被成功清理，没有副作用。
2. 克隆子树失败，清理子树也失败，游离在了文件系统之外，导致元数据泄露和可能的对象存储泄露。此时如果源对象被删除了，则会导致其对象存储上的数据不会被释放（因为被未挂载的的子树所引用），直到使用 `juicefs gc --delete` 命令清理。克隆子树阶段进程被中断掉了属于也这第二种情况，因为删除子树环节还没有被执行。
