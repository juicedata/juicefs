name: "version-compatible-test"

on:
  schedule:
    - cron:  '2 0 * * *'
  workflow_dispatch:

jobs:
  version-compatible-test:
    runs-on: [self-hosted, daily-build, bench-03]
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          fetch-depth: 1

      - name: Set Variable
        id: vars
        run: |
          echo ::set-output name=META_URL::redis://mymaster,172.27.0.1,172.27.0.2,172.27.0.3:26379/8
          echo ::set-output name=MINIO_URL::http://172.27.0.2:9005/juicefs-version-compatible
          echo ::set-output name=MOUNT_POINT::/tmp/juicefs-version-compatible

      - name: Build linux target
        run: |
          export GOPATH=/usr/local/go
          export HOME=/root
          make juicefs
          mv juicefs jfs_new
          echo juicefs new version: $(./jfs_new -V)

      - name: Init
        run: |
          if [ -d ${{ steps.vars.outputs.MOUNT_POINT }} ]; then
            ./juicefs umount ${{ steps.vars.outputs.MOUNT_POINT }} || true
          fi
          UUID=$(./juicefs status ${{ steps.vars.outputs.META_URL }} | grep UUID | cut -d '"' -f 4)
          if [ -n "$UUID" ];then
            sudo ./juicefs destroy --force ${{ steps.vars.outputs.META_URL }} $UUID
          fi

      - name: Version Compatible Test
        run: |
          tests=(
              "format:jfs_old, mount:jfs_old, write_file1_20M:jfs_old, umount:jfs_old, format:jfs_new, mount:jfs_new, read_file1:jfs_old, destroy:jfs_old",
              "format:jfs_old, format:jfs_new,  destroy:jfs_old"
          )    
          urls=($(curl -s https://api.github.com/repos/juicedata/juicefs/releases | grep browser_download_url | grep linux-amd64.tar.gz | awk -F\" '{print $4}' | head -5) )  
          for url in "${urls[@]}"; do 
              echo download url is: $url
              wget -q $url
              tar -zxf $(basename $url)
              rm $(basename $url)
              mv juicefs jfs_old
              echo juicefs new version: $(./jfs_new -V)
              echo juicefs old version: $(./jfs_old -V)
              for test in "${tests[@]}"; do
                  echo 'test is ' $test
                  IFS=',' read -a command_arr <<< "$test"
                  for command in "${command_arr[@]}"; do
                      jfs_bin=$(echo $command | awk -F: '{print $2}'| xargs)
                      jfs_cmd=$(echo $command | awk -F: '{print $1}'| xargs | awk -F_ '{print $1}')
                      echo 'jfs_bin is ' $jfs_bin, "cmd is "  $jfs_cmd
                      case "$jfs_cmd" in
                        "format") 
                            sudo ./$jfs_bin format --storage minio --bucket  ${{ steps.vars.outputs.MINIO_URL }} --access-key minioadmin --secret-key ${{ secrets.MINIO_SECRET_KEY }}  ${{ steps.vars.outputs.META_URL }} juicefs-version-compatible
                            echo "cmd is format" 
                            ;;
                        "mount") 
                            sudo ./$jfs_bin mount ${{ steps.vars.outputs.META_URL }}  ${{ steps.vars.outputs.MOUNT_POINT }} 
                            echo "cmd is mount" 
                            ;;
                        "umount") 
                            sudo ./$jfs_bin umount ${{ steps.vars.outputs.MOUNT_POINT }} 
                            echo "cmd is mount" 
                            ;;
                        "destroy") 
                            UUID=$(./$jfs_bin status ${{ steps.vars.outputs.META_URL }} | grep UUID | cut -d '"' -f 4)
                            if [ -n "$UUID" ];then
                              echo UUID is $UUID
                              sudo ./$jfs_bin destroy --force ${{ steps.vars.outputs.META_URL }} $UUID
                            fi
                            echo "cmd is destroy" 
                            ;;
                        "write") 
                            filename=$(echo $command | awk -F: '{print $1}'| xargs | awk -F_ '{print $2}')
                            size=$(echo $command | awk -F: '{print $1}'| xargs | awk -F_ '{print $3}')
                            dd if=/dev/random of=${{ steps.vars.outputs.MOUNT_POINT }}/tempfile bs=4k count=$size
                            md5_write="$filename:$(cat ${{ steps.vars.outputs.MOUNT_POINT }}/tempfile | md5)"
                            echo "write: filename is: " $filename "md5_write is: "" $md5_write
                            copy ${{steps.vars.outputs.MOUNT_POINT}}/tempfile $filename
                            echo "cmd is write" 
                            ;;
                        "read") 
                            filename=$(echo $command | awk -F: '{print $1}'| xargs | awk -F_ '{print $2}')
                            read_md5=$(cat $filename | md5)
                            written_filename=$(echo $md5_write | awk -F: '{print $1}')
                            written_md5=$(echo $md5_write | awk -F: '{print $2}')
                            echo "read: filename is: " $filename "read_md5 is: "" $read_md5, "written_filename is:", $written_filename, "written_md5 is:", $written_md5, 
                            if [ "$filename" == "$wrtten_filename" && "$read_md5" != "$written_md5" ];then
                              echo "FATAL: the md5 does not match for: ", $filename, "read_md5:", $read_md5, "written_md5:", $written_md5
                            fi
                            ;;
                      esac
                  done
              done
          done

      - name: Send Slack Notification
        if: ${{ failure() }}
        uses: juicedata/slack-notify-action@main
        with:
          channel-id: "${{ secrets.SLACK_CHANNEL_ID_FOR_PR_CHECK_NOTIFY }}"
          slack_bot_token: "${{ secrets.SLACK_BOT_TOKEN }}"  